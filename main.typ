#set text(lang: "ru") // форматирование будет потом

= Программная реализация алгоритмов компенсации траекторных отклонений для синтеза радиолокационных изображений

= Введение
Радиолокационное синтезирование апертуры является одной из ведущих технологий дистанционного зондирования, позволяющей получать детальные изображения земной и водной поверхности вне зависимости от погодных условий. Радиолокаторы с синтезированной апертурой (РСА) являются активными средствами наблюдения, т.е. используют облучение пространства зондирующим сигналом, приём и обработку отражённых сигналов. Полученные голограммы затем позволяют синтезировать радиолокационные изображения, содержащие информацию о свойствах объекта наблюдения. 

Основное отличие синтезированной апертуры от реальной заключается в том, что синтезированная апертура формируется последовательно во времени, при этом каждый момент времени приём сигнала производится реальной апертурой. Синтезирование апертуры осуществляется за счёт приёма сигнала реальной апертурой при различном её положении относительно источника. В каждом положении РЛС излучает зондирующей импульс и принимает его отражение от точечной цели (или земной поверхности). Параметры принятого сигнала --- амплитуда и фаза записываются в запоминающее устройство и затем подвергается обработке различными алгоритмами для, непосредственно, синтеза изображения. Такой метод позволяет получить апертуру большого размера, используя антенну малого размера, и, как следствие, большее линейное разрешение.

Таким образом, радиолокационная съёмка обладает рядом преимуществ в сравнении с оптическими средствами наблюдения [Верба]:
- Независимость от метеорологических условий и освещённости.
- Повышенная точность измерения геометрических характеристик объектов.
- Возможность построения карт рельефа.
- Возможность определения диэлектрических, динамических характеристик объектов наблюдения.
- Возможность наблюдения объектов, невидимых в оптическом и ИК-диапазонах, например, скрытых снежным или растительным покровом.
- Возможность получения дополнительной информации об объектах на основании их электродинамических свойств.
Однако, системы РСА имеют ряд ограничений:
- Малая длительность наблюдения цели --- менее чем единицы минут в зависимости от режима работы, большие интервалы повторной съёмки (характерно для РСА космического базирования).
- Существенные геометрические искажения и размытие РЛИ, вызванные нестабильным и неравномерным движением платформы-носителя (характерно для РСА авиационного базирования).
- Опасность подавления РСА путём создания мощной помехи.
Вышеописанные особенности систем РСА позволяют использовать их в различных отраслях ДЗЗ. В настоящее время системы аэрокосмического мониторинга на базе РСА используются для решения следующих задач: 
- Всепогодное слежение за земной и водной поверхностью.
- Построение цифровых моделей рельефа.
- Прогнозирование глобальных природных процессов
- Поиск и идентификация объектов
- Контроль состояния объектов путём отслеживания их электродинамических свойств или геометрических характеристик

Одним из вариантов исполнения системы РСА является РСА авиационного базирования. Такой вариант обладает некоторыми важными преимуществами перед РСА космического базирования. В первую очередь, авиационные РСА обладают большей мобильностью, т.е. траектория носителя РСА может иметь практически любую геометрию, что позволяет использовать различные режимы работа в зависимости от задачи. Также немаловажно, что разработка и развёртывание таких систем может быть значительно проще и быстрее, что существенно повышает оперативность решения задач наблюдения. 

Однако, РСА авиационного базирования обладают существенным недостатком: траектория движения носителя такой системы подвержена существенным искажениям относительно идеального равномерного и прямолинейного движения, вызванным флуктуациями и другими процессами, происходящими в атмосфере. Такие траекторные нестабильности (ТН) приводят к геометрическим искажениям и размытию получаемых РЛИ. Вследствие этого, становится актуальной задача компенсации ТН при синтезе изображений. Традиционным способом решения данной проблемы является дополнительная процедура автофокусировки изображения (оценка оптимальных параметров синтеза), которая существенно увеличивает вычислительную нагрузку и приводит к потере радиометрических и геометрических характеристик. Микроминиатюризация, усовершенствование инерциальных датчиков и высокоточных средств определения положения с помощью ГНСС (до нескольких сантиметров) позволяют в данный момент получать точную информацию о положении и ориентации носителя РСА во время съемки и учитывать ее для компенсации траекторных искажений. Преимуществом данного подхода является возможность избежать процедуры автофокусировки путём корректировки существующих алгоритмов синтеза изображений с сохранением радиометрических и геометрических характеристик РЛИ. Таким образом, целью данной работы является реализация вышеописанной процедуры компенсации ТН для дальностно-доплеровского алгоритма, анализ качества реализации на модельных радиолокационных и навигационных данных и верификация с использованием реальных данных самолётного РСА. Обоснование выбора данного алгоритма и подходов к компенсации ТН приведено далее.

== Схема работы РСА
Геометрия радиолокационного обзора представлена на @fig:sar_geometry. По мере движения платформы, на которую установлена радиолокационная система, радар периодически излучает сигнал, после чего регистрирует его отражение от поверхности. ДН антенной системы направлена в сторону от траектории движения, в некоторых системах это направление не перпендикулярно ей, т.е. имеет место _угол скоса_.

Существуют различные режимы работы систем РСА, наиболее распространённые из них:
- _Маршрутный режим_ --- непрерывная съёмка фиксированной полосы вдоль трассы полёта.
- _Прожекторный режим_ --- направление ДН антенны непрерывно подстраивается для съёмки определённой точки поверхности.
- _Обзорный режим_ --- увеличение ширины полосы съёмки путём использования нескольких лучей

В данной работе рассматривается РСА в маршрутном режиме работы при нулевом угле скоса.

 #figure(
    image("images/SAR_geometry.svg", width: 70%), // линии из ФЦ, заглавные буквы
    caption: [Геометрия работы РСА],
  )<fig:sar_geometry> 

Циклограмма сигнала, излучаемого и принимаемого антенной системой РСА, изображена на @fig:recv_signal. В начале периода излучается сигнал $t_r$. Затем аппаратура переключается на приём. Принятый сигнал записывается с момента $t_1$ (соответствующего началу прихода отражённого сигнала от объектов на ближней границе $R_1$), до момента $t_2$ (соответствующего окончанию прихода отражённого сигнала от объектов на дальней границе $R_2$). Описанный период повторяется с интервалом _PRI_.

  #figure(
    image("images/recv_signal.svg", width: 70%),
    caption: [Циклограмма излучения и приёма сигнала РСА], // отметить t_r, t_2=t_2+t_r, опечатка
  )<fig:recv_signal>

== Постановка задачи
 Как было сказано выше, одной из проблем, возникающих при синтезе изображения, полученного с РСА, является необходимость точного знания фазы траекторного сигнала, что равносильно ошибке положения точек апертуры относительно заданного. Эта необходимость обусловлена тем, что существующие алгоритмы синтеза РЛИ, как правило, предполагают равномерное прямолинейное движение платформы РСА. Одной из основных причин возникновения этих ошибок являются траекторные нестабильности платформы РСА, которые особенно характерны для РСА авиационного базирования. Допустимая ошибка в знании траектории фазового центра антенны составляет несколько миллиметров для сантиметрового диапазона волн. Этим обусловлена необходимость использования специальных алгоритмов компенсации траекторных нестабильностей.

 Таким образом, при реализации данных алгоритмов были сформулированы следующие задачи:
 - Реализовать и внедрить процедуру компенсации траекторных отклонений в дальностно-доплеровском алгоритма синтеза для изображений РСА самолетного базирования.
 - Провести анализ качества реализованных алгоритмов коррекции траекторных искажений по модельным радиолокационным и навигационным данным.
 - По результатам анализа сделать вывод о требованиях к точности навигационной информации для обеспечения заданных характеристик радиолокационных изображений (РЛИ).
- Верифицировать алгоритмы с использованием реальной навигационной информации при синтезе РЛИ экспериментального самолетного РСА X-диапазона.

План работы ...

== А
== Б
== В

= Алгоритмы синтеза РЛИ и коррекции ТН

== Дальностно-доплеровский алгоритм
Дальностно-доплеровский алгоритм разработан в 1978 году и является одним из наиболее распространённых алгоритмов синтеза РЛИ. Схема алгоритма с модификациями для коррекции ТН (будут рассмотрены далее) показана на @fig:RDA_model. Отличительной особенностью алгоритма является операция коррекции миграции дальности, которая выполняется во временной области по дальности и в частотной области по азимуту (области доплеровских частот). 

  #figure(
    image("images/RDA_model.svg", width: 70%), // опечатка, переинтерполяция
    caption: [Блок-схема алгоритма ДДА],
  )<fig:RDA_model>

Далее рассматриваются математические преобразования, осуществляемые на каждом шаге. Сигнал, отражённый от точечной цели после демодуляции, имеет вид:

$ s_0(tau, eta) =& \
& A_0 times && dash.em quad "некоторая константа" \
& times omega_r (tau - 2R(eta) slash c) && dash.em quad "огибающая по дальности (прямоуг.)" \ 
& times omega_a (eta - eta_c) && dash.em quad "огибающая по азимуту" (~sinc^2) \
& times exp(-j dot 4pi f_0 R(eta) slash c) && dash.em quad "остаточная фаза несущей" \
& times exp(j dot pi K_r (tau - 2R(eta) slash c)^2) quad && dash.em quad "фаза ЛЧМ импульса," $<eq:raw_signal>

// spacing

$"где" quad &tau && dash.em quad "время по дальности (быстрое)" \
&eta && dash.em quad "время по азимуту (медленное)" \
&f_0 && dash.em quad "частота несущей" \
&K_r && dash.em quad "скорость ЛЧ-модуляции" \
&R(eta) quad && dash.em quad "наклонная дальность"$ // ref to eq

Величина $eta_c$ обозначает момент по оси "медленного" времени, когда доплеровская частота для данной цели равна нулю. Наклонная дальность определяется соотношением 
$ R(eta) = sqrt(R_0^2 + v_r^2eta^2), $<eq:slant_range>
где $R_0$ --- дальность ближайшего подлёта (см. @fig:sar_geometry), а $eta = 0$ в момент ближайшего подлёта к данной цели (для нескольких целей $eta$ обозначает абсолютное время, и $eta = 0$ в центре изображения).

=== Сжатие сигнала по дальности
Производится путём умножения ПФ по дальности исходного сигнала /*@eq:raw_signal*/ на согласованный фильтр, представляющий из себя комплексно сопряжённое ПФ дополненного нулями единичного ЛЧМ-импульса длительностью $t_r$ (см. @fig:recv_signal)
$ g(tau) = exp(j dot pi K_r tau^2), quad {-t_r slash 2 < tau < t_r slash 2}, $ и взятия ОПФ по дальности полученного произведения. Полученное преобразование записывается как:
$ s_(r c) (tau, eta) &= "IFFT"_tau { "FFT"_tau [ s_0 (tau, eta) ] times "FFT"_tau [ g (tau) ]^* } = \
&= A_0 dot p_r (tau - 2R(eta) slash c) dot omega_a (eta - eta_c) dot exp(-j dot 4pi f_0 R(eta) slash c), $<eq:after_rc>
где $p_r (tau)$ --- функция $~sinc$. В результате данного преобразования из сигнала была исключена квадратичная по $tau$ компонента фазы.

=== БПФ по азимуту
Переводит голограмму в частотную (доплеровскую) область по этой оси. Для малых углов скоса можно воспользоваться приближением /*@eq:slant_range*/:
$ R(eta) = sqrt(R_0^2 + v_r^2eta^2) approx R_0 + (v_r^2 eta^2)/(2 R_0). $<eq:slant_range_approx>
Тогда /*eq:after_rc>*/ можно представить в виде
$ s_(r c) (tau, eta) approx A_0 dot p_r (tau - (2R(eta)) / c) dot omega_a (eta - eta_c) dot exp(-j (4pi f_0 R_0) / c) dot exp(-j pi (2 v_r^2)/(lambda R_0) eta^2) $<eq:rc_approx>
Последний множитель имеет квадратичную по $eta$ фазу (как у ЛЧМ-импульса), поэтому можно ввести скорость ЛЧ-модуляции по азимуту $ K_a approx (2 v_r^2)/(lambda R_0) $<eq:K_a>
Из ПСФ получаем $ f_eta = -K_a eta $<eq:POSP_f_eta>
Подставляя $eta = -f_eta slash K_a$ в /*@<eq:rc_approx>*/, после БПФ по азимуту получаем
$ S_1 (tau, f_eta) &= "FFT"_eta [s_(r c) (tau, eta)] = \
&= A_0 dot p_r (tau - (2R_(r d) (f_eta)) / c) dot W_a (f_eta - f_eta_c) dot exp(-j (4pi f_0 R_0) / c) dot exp(j pi f_eta^2 / K_a) $<eq:after_fft_eta>
Выражение /*@<eq:slant_range_approx>*/ с учётом /*@<eq:POSP_f_eta>*/ теперь может быть преобразовано как
$ R_(r d) (f_eta) approx R_0 + v_r^2/(2R_0) (f_eta / K_a)^2 = R_0 + (lambda^2 R_0 f_eta^2) / (8 v_r^2) $<eq:slant_range_approx_f_eta>

=== Вторичное сжатие по дальности
Выполняется путём умножения на согласованный фильтр в частотно-доплеровской области для того, чтобы уменьшить искажения, связанные с взаимозависимостью дальности и азимута друг от друга. В вышеописанных формулах эта зависимость опущена для упрощения, вывод же более точных соотношений весьма громоздкий и здесь не приводится.

=== Коррекция миграции дальности
Производится путём интерполяции в частотной по дальности и азимуту области. Из /*@<eq:slant_range_approx_f_eta>*/ получаем $ R_(r d) (f_eta) = R_0 (1 + (lambda^2 f_eta^2) / (8 v_r^2)), $ т.е. миграция дальности происходит за счёт умножения на зависящий от $f_eta$ коэффициент. Интерполяция на новую дальность сигнала после предыдущего шага позволяет избавиться от этого множителя, в итоге получаем
$ S_2 (tau, f_eta) = A_0 dot p_r (tau - (2R_0) / c) dot W_a (f_eta - f_eta_c) dot exp(-j (4pi f_0 R_0) / c) dot exp(j pi f_eta^2 / K_a) $<eq:after_rcmc>

=== Сжатие по азимуту
Выполняется путём умножения на согласованный фильтр такой, чтобы исключить квадратичную по $f_eta$ компоненту фазы. Такой фильтр имеет вид 
$ H_("az") (f_eta) = exp(-j pi f_eta^2/K_a) $<eq:az_compr_filt>
Полученный после умножения сигнал
$ S_3 (tau, f_eta) &= S_2 (tau, f_eta) times H_("az") (f_eta) = \
&= A_0 dot p_r (tau - (2R_0) / c) dot W_a (f_eta - f_eta_c) dot exp(-j (4pi f_0 R_0) / c) $<eq:after_ac>

=== ОБПФ по азимуту
В итоге после финальной операции сигнал имеет вид
$ s_(a c) (tau, eta) &= "IFFT"_eta [S_3 (tau, f_eta)] = \
&= A_0 dot p_r (tau - (2R_0) / c) dot p_a (eta) dot exp(-j (4pi f_0 R_0) / c) exp(j space 2pi f_eta_c eta), $
где $p_a (eta)$ --- функция $~sinc$. Таким образом, координаты цели теперь соответствуют #box[$tau = 2R_0 slash c$ и $eta = 0$].

== Алгоритм $Omega$ --- $k$
Алгоритм  $Omega$ --- $k$ является одним из широко применяемых методов обработки сигналов РСА. Особенностью этого алгоритма является использование специальных математической операции в частотной области, которые исправляют вклад взаимозависимости дальности и азимута, а также вклад зависимости от частоты по азимуту. Также, данный алгоритм позволяет обрабатывать сигналы РСА с широкими апертурами по азимуту или большими углами скоса.

Основные этапы алгоритма $Omega$ --- $k$ включают:
+ Двумерное БПФ. Оно переводит сигнал в частотную область.
+ Умножение на согласованный фильтр. СФ представляет из себя функцию, вычисленную для заданной дальности (как правило, средней). Таким образом, эта функция исправляет набег фазы на данной заданной дальности, включая набег от модуляции по дальности и азимуту, миграции дальности и взаимозависимость дальности и азимута. Данная операция полностью фокусирует цели на заданной дальности, но иных дальностях цели фокусируются не полностью.
+ Интерполяция Столта. Данная операция проводит дофокусировку остальных целей с использованием интерполяции по оси дальности.
+ Двумерное ОБПФ.

Для синтеза РЛИ выбран дальностно-доплеровский алгоритм как наиболее простой в реализации, а также позволяющий проводить контроль промежуточных этапов обработки.

== Компенсация траекторных нестабильностей
Для РСА авиационного базирования траекторные искажения вносят существенную фазовую ошибку (в сравнении с длиной волны в единицы см), вызывая разрушения РЛИ. Следствиями фазовых искажений при синтезе РЛИ являются: 
- Смещение максимума, что приводит к ошибкам измерения координат объектов
- Уменьшение максимума выходного сигнала, что равносильно снижению энергетического потенциала РЛС
- Расширения главного лепестка отклика точечной цели, что приводит к ухудшению разрешающей способности
- Увеличение уровня мощности боковых лепестков отклика цели, что снижает контраст РЛИ
Существуют различные подходы к компенсации ТН, далее рассмотрены наиболее распространённые из них.

== Автофокусировка

=== Фазово-градиентная автофокусировка
Алгоритм фазово-градиентной автофокусировки --- это вычислительно-затратный алгоритм обработки сигнала РСА, повышающий качество РЛИ путем исправления ошибок набега фазы, возникающих в процессе сбора данных. Такие фазовые ошибки могут быть вызваны различными факторами, включая нестабильное движение носителя, атмосферные возмущения и несовершенство системы. Алгоритм ФГА предназначен для более точной фокусировки РЛИ, улучшения разрешения и детализации.

Алгоритм ФГА основан на принципе фазовой коррекции полученных РСА сигналов. Основные этапы работы алгоритма можно описать следующим образом:
+ Оценка фазовой ошибки. Обычно это достигается путем анализа фазы принимаемых сигналов на некотором диапазоне пикселей изображения. Алгоритм вычисляет фазовый градиент, который показывает, как меняется фаза на изображении.
+ Расчет градиента. Фазовый градиент рассчитывается с использованием локальных пространственных производных фазы. Исследуя небольшие области изображения, алгоритм определяет, насколько сильно изменяется фаза от пикселя к пикселю. Этот градиент позволяет получить представление о природе и степени фазовых ошибок, влияющих на изображение.
+ Фазовая коррекция. Эта коррекция включает в себя подстройку фазы каждого пикселя на основе рассчитанного градиента. Цель состоит в том, чтобы правильно выровнять фазы различных пикселей, тем самым уменьшая размытость и улучшая фокусировку.
+ Итеративное уточнение. Для уточнения фазовых оценок и корректировок в алгоритме ФГА часто используется итеративный подход, при котором данные обрабатываются многократно. Каждая итерация повышает точность фазовой коррекции, что приводит к получению все более качественных изображений.

=== Map-drift
из вербы

== Фазовые множители <ref:phase_multi>
Данный подход основан на использовании навигационных данных, полученных от БИНС платформы. БИНС самолёта или БПЛА позволяет с помощью данных ГНСС или инерциальных измерений получить фактическое положение платформы в момент приёма отражённого сигнала. Таким образом, можно вычислить расстояние между фактическим и предполагаемым положением фазового центра антенны в момент приёма. Эта разница равносильна фазовой ошибке и дополнительной задержке сигнала, которая искажает отклик цели и должна быть исправлена. В данной работе коррекция траекторных искажений выполняется двумя методами (см. @fig:RDA_model): «точным» и «приближённым» [E. Zaugg].

=== "Точный" метод
  #figure(
    image("images/MOCO_geometry.svg", width: 70%),
    caption: [Изменение наклонной дальности при траекторных отклонениях],
  )<fig:MOCO_geometry>

  #figure(
    image("images/precise_corr.svg", width: 50%),
    caption: [Изменение циклограммы сигнала при траекторных отклонениях],
  )<fig:recv_signal_error>
  
В результате влияния траекторных нестабильностей изменяется дальность до цели (см. @fig:MOCO_geometry), тем самым изменяется фаза отклика цели и его момент регистрации (см. @fig:recv_signal_error), то есть отклику данной цели будет соответствовать иное положение на оси времени и, соответственно, дальности. В данном методе изменение фазы компенсируется умножением на согласованный фильтр, зависящим от времени по азимуту и от искажения траекторного сигнала на заданной дальности
$ H_("mc") (eta, Delta R_"ref") = exp(j dot 4 pi f_0 Delta R_("ref")(eta)), $<eq:precise_corr>
а смещение по времени компенсируется интерполяцией сигнала по "быстрому" времени. В результате, искажения для заданной цели будут полностью устранены, а цели на других дальностях останутся частично дефокусированными, но в меньшей степени, чем без компенсации.

=== "Приближённый" метод
В данном методе искажение наклонной дальности для каждой цели (т.е. ячейки по дальности в случае множества целей) представляется как сумма двух слагаемых:
$ Delta R(eta) = Delta R_("ref")(eta) +  Delta R_("diff")(eta), $ <eq:deltaR_decomp>
где $Delta R_("ref")(eta)$ --- искажение заданной наклонной дальности, а $Delta R_("diff")(eta)$ --- искажение наклонной дальности до каждой ячейки по дальности за вычетом предыдущего слагаемого, т.е. относительно заданной дальности.
Зависимость от времени по азимуту выражается в зависимости величины искажения от такового, а непосредственно сами дальности вычисляются до соответствующей прямой, параллельной оси азимута, т.е. они не зависят (константы) от азимута. Так как заданная наклонная дальность определена заранее и постоянна, первое слагаемое не зависит от произвольной дальности (т.е. координаты по дальности), а второе слагаемое от этой координаты зависит, что будет использовано далее.
Первый тип слагаемых компенсируется перед операцией сжатия по дальности, второй – сразу после неё. Данный метод позволяет получить приемлемое разрешение при исключении дорогостоящей в вычислительном плане операции интерполяции.

Рассмотрим подробнее математические соответствующие преобразования. В исходном сигнале /*@eq:*/ фазовую часть (без учёта огибающих) можно представить в виде:
$ s_0(tau, eta) = &exp(-j dot 4pi f_0 (R(eta) + Delta R_("ref")(eta) +  Delta R_("diff")(eta))/c) dot \
dot &exp(j dot pi K_r (tau - 2 (R(eta) + Delta R_("ref")(eta) +  Delta R_("diff")(eta))/c)^2) $
Это выражение можно разбить на множители следующим образом:
$ s_0(tau, eta) = &exp(-j dot 4pi f_0 R(eta) slash c) dot exp(j dot pi K_r (tau - 2 R(eta) slash c)^2) dot \
dot &exp(j dot 4pi  K_r (Delta R_("ref")(eta) ^2) / (c^2)) dot exp(-j dot 4pi f_0 (Delta R_("ref")(eta)) / (c)) dot \
dot &exp(-j dot 4pi K_r tau Delta R_("ref")(eta) slash c) dot \
dot &exp(j dot 8pi K_r Delta R_("ref")(eta)(Delta R_("diff")(eta) + R(eta)) slash c^2) dot \
dot &exp(j dot 4pi  K_r (Delta R_("diff")(eta) ^2) / (с^2)) dot exp(j dot 8pi  K_r (R(eta) Delta R_("diff")(eta)) / (c^2)) dot \
dot &exp(-j dot 4pi f_0 (Delta R_("diff")(eta)) / (c)) dot exp(-j dot 4pi K_r tau (Delta R_("diff")(eta)) / (c)),
$
где первые два множителя --- неискажённый сигнал, следующие три --- независящие от координаты по оси дальности искажения, а последние пять --- зависящие от неё.

Первый шаг коррекции применяется к исходной голограмме и выражается умножением на согласованный фильтр
$ H_("mc1") = exp(-j dot 4pi Delta R_("ref")(eta) (-f_0 c - K_r tau c + K_r Delta R_("ref")(eta)) / (c^2)), $ <eq:approx_corr_mc1>
который устраняет независящие от координаты по дальности искажения.

После сжатия по дальности один отсчёт голограммы по дальности будет соответствовать одной ячейке по дальности, и для компенсации зависящих от координаты по дальности искажений используется согласованный фильтр
$ H_("mc2") = &exp(-j dot 8pi K_r Delta R_("ref")(eta)(Delta R_("diff")(eta) + R(eta)) slash c^2) dot \ 
dot &exp(-j dot 4pi  K_r (Delta R_("diff")(eta) ^2) / (с^2)) dot exp(-j dot 8pi  K_r (R(eta) Delta R_("diff")(eta)) / (c^2)) dot \
dot &exp(j dot 4pi f_0 (Delta R_("diff")(eta)) / (c)) dot exp(j dot 4pi K_r tau (Delta R_("diff")(eta)) / (c)) $ <eq:approx_corr_mc2>

= Реализация (Модель)
== Реализация модели для точечных сигналов
Для анализа и оценки рассматриваемых подходов к компенсации ТН используется модель РСА авиационного базирования, блок-схема которой представлена на @fig:model_scheme.

  #figure(
    image("images/Point_target_model.svg", width: 50%),
    caption: [Блок-схема модели],
  )<fig:model_scheme>

=== Инициализация модели
Входные параметры модели описаны в /*@tab:model_params*/.

#figure(
  table(
    columns: (auto, auto),
    align: (right, left),
    table.header(
      [*Параметр*], [*Обозначение*], // поменять местами
    ),
    [Разрешение по азимуту], [$"res"_a$],
    [Разрешение по дальности], [$"res"_r$],
    [Высота полёта], [$h$],
    [Угол раствора ДН], [$alpha$],
    [Скорость движения платформы], [$v$],
    [Длительность импульса], [$t_r$],
    [Ширина полосы излучаемого ЛЧМ сигнала], [_bw_],
    [Частота повторения импульса], [_prf_],
    [Частота несущей], [$f_0$],
    [Начальная координата платформы по оси _Y_], [$y_0$],
    [Ближняя граница], [$R_"min"$],
    [Дальняя граница], [$R_"max"$],
    [Время пролёта], [$T$],
    [Амплитуда ТН по оси _X_], [_dis_x_ampl_],
    [Частота ТН по оси _X_], [_dis_x_freq_],
    [Координаты целей], [-],
  ),
  caption : [Входные параметры модели для точечных целей]
)<tab:model_params>

В модели предполагается (см. @fig:model_geometry), что платформа (в идеальном случае) движется в 3-х мерном декартовом пространстве вдоль оси _X_ (т.е. по прямой $x = 0$) начиная с координаты $y_0$ в течение времени $T$ с постоянной скоростью $v$ на постоянной высоте $h$ по оси _Z_. Точечные цели расположены на высоте $h = 0$ в указанных координатах $(x, y)$. Диаграмма направленности имеет вид функции $sinc("scale" dot x)$ такой, что координаты $x = plus.minus a l p h a$ соответствуют уменьшению функции на 3 дБ относительно максимума, а максимум функции соответствует минимальной дальности подлёта к цели. Визуализация параметров зондирующего импульса представлена на @fig:recv_signal.

  #figure(
    image("images/Model_geometry.svg", width: 70%),
    caption: [Геометрия движения носителя РСА в модели],
  )<fig:model_geometry>

=== Генерация массива траекторных отклонений
В данной модели траекторные искажения представляются в виде гармонической функции с амплитудой _dis_x_ampl_ и частотой _dis_x_freq_, которая прибавляется к соответствующим координатам траектории платформы (в данном случае к оси _X_).

=== Генерация голограммы
Для каждой точечной цели с учётом ближней и дальней границы, а также ширины ДН и параметров сигнала вычисляется отклик для каждого положения платформы в момент излучения-приёма (т.е. для каждого отсчёта по азимуту). При вычислении фазы и времени регистрации полученного сигнала используется дальность до цели, вычисленная с учётом искажения траектории движения платформы. Полученные отклики взвешиваются на ДН антенны и объединяются в двумерный массив --- полученную голограмму. Размер массива по дальности определяется ближней, дальней границами и частотой дискретизации _f_s_, которая принимается равной $1,3 dot b w$.

=== Синтез РЛИ алгоритмом ДДА
Полученная голограмма затем обрабатывается дальностно-доплеровским алгоритмом (см гл. /*ссыл_очка*/) с применением различных модификаций для компенсации ТН. Данные модификации применяются в зависимости от метода компенсации ТН, который требуется проанализировать. На каждом шаге работы ДДА производится контроль полученного РЛИ.

=== Анализ полученного изображения и контроль качества
На данном этапе производится интерполяция изображения каждой точечной цели, которое затем используется для оценки полученного разрешения и иных параметров.

== Анализ функции отклика точечной цели на РЛИ
//выделить портрет n x n
//Интерполяция в частотной области с помощью добавления нулей
//Нахожение макс, ыделение профиля
//Измерение одномерных характеристик
//res_r, res_a, PSLR, ISLR
//Пример
Оценка качества полученных изображений производится по следующим параметрам: разрешение по азимуту и дальности, относительный и интегральный уровень мощности боковых лепестков. Пример последовательности работы с РЛИ для определения данных параметров изображена на @fig:image_analysis. Для анализа данных параметров на РЛИ выделяется портрет выбранного отклика, который затем интерполируется путём добавления нулей в частотной области. На полученном изображении определяется положение максимума и производится сечение профиля. Полученное сечение позволяет оценить выбранные параметры. Вывод о результатах компенсации траекторный нестабильностей двумя методами и о пределах их применимости делается по итогам анализа параметров функций отклика всех точечных целей, заданных на сцене.

  #figure(
    image("images/Image_analysis.svg", width: 100%),
    caption: [Последовательность анализа параметров РЛИ],
  )<fig:image_analysis>
  
= Результаты моделирования
Для моделирование работы алгоритмов компенсации симуляции производится в следующем порядке:
+ Проверка реализации ДДА --- при отсутствии ТН
+ Демонстрация влияния искажений --- добавлены ТН, но без компенсации
+ Исследование алгоритмов компенсации --- при различной величине ТН
На каждом этапе проводится анализ интересующих промежуточных и итоговых результатов работы модели для оценки соответствующих параметров.
== Проверка реализации ДДА <ref:NoDis>
Для проверки корректности работы реализации алгоритма сначала проводится симуляция без добавления ТН. Значения параметров модели приведены в /*@tab:*/. 

#figure(
  table(
    columns: (auto, auto),
    align: (right, left),
    table.header(
      [*Параметр*], [*Значение*],
    ),
    [$"res"_a$], [0,3 м],
    [$"res"_r$], [0,22 м],
    [$h$], [800 м],
    [$alpha$], [10#sym.degree],
    [$v$], [50 м/с],
    [$t_r$], [5 мкс],
    [_bw_], [600 МГц],
    [_prf_], [720 Гц],
    [$f_0$], [9,275 ГГц],
    [$y_0$], [$-1000 dot tan(alpha slash 2) $ м],
    [$R_"min"$], [2000 м],
    [$R_"max"$], [3800 м],
    [$T$], [3,5 с],
    [*_dis_x_ampl_*], [*0 м*],
    [_dis_x_freq_], [$2 slash T$ Гц]
  ),
  caption : [Параметры симуляции]
)<tab:rda_model_params>

Координата $y_0$ выбрана для простоты таким образом, чтобы цели на оси $x = 0$ были на середине изображения. Координаты целей приведены в /*@tab:*/. 

#figure(
  table(
    columns: (auto, auto),
    align: (right, left),
    table.header(
      [*Номер цели*], [*Координаты*],
    ),
    [1], [(2100, 0)],
    [2], [(2800, 0)],
    [3], [(3500, 0)],
    [4], [(2100, 50)],
    [5], [(2800, 50)],
    [6], [(3500, 50)],
    [7], [(2100, -50)],
    [8], [(2800, -50)],
    [9], [(3500, -50)],
  ),
  caption : [Координаты целей для симуляции]
)<tab:target_coords>

Рассмотрим промежуточные шаги обработки голограммы на примере цели #2.

Фрагменты голограммы с выбранной целью после последовательного выполнения операций алгоритма представлены на @fig:NoDis_fragments. Красной линией показан закон изменения дальности до цели в соответствующих координатах (выведен в Гл. /*про ДДА*/). Как видно из изображений, данный закон совпадает с откликом цели. На срезе полученного изображения цели видно, что его разрешения по азимуту и дальности, а также координаты  соответствуют заданным. Аналогичный результат получается для остальных целей. Таким образом, ДДА реализован корректно.

 #figure(
    table(
    columns: (auto, auto),
    stroke: none,
    align: (center, center),
    [#image("images/no_dis/NoDis_pulse_compr.svg", width: 100%)],
    [#image("images/no_dis/NoDis_azimuth_fft.svg", width: 100%)],
    [а)], [б)],
    [#image("images/no_dis/NoDis_rcmc.svg", width: 100%)],
    [#image("images/no_dis/NoDis_final.svg", width: 100%)],
    [в)], [г)],
    [#image("images/no_dis/NoDis_azimuth_slice.svg", width: 120%)],
    [#image("images/no_dis/NoDis_range_slice.svg", width: 120%)],
    [д)], [е)],
  ),
    caption: [Фрагменты голограммы после выполнения операций: сжатия по дальности (а), БПФ по азимуту (б), коррекции миграции дальности (в); Полученное изображение цели (г), его сечения по азимуту (д) и дальности (е).],
    kind: image,
  )<fig:NoDis_fragments>

Также на @fig:NoDis_scene -- @fig:NoDis_targets представлено изображение сцены и РЛИ всех целей.

 #figure(
    image("images/no_dis/NoDis_scene.svg", width: 80%),
    caption: [РЛИ моделируемой сцены],
 )<fig:NoDis_scene>

  #figure(
    image("images/no_dis/NoDis_targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )<fig:NoDis_targets>

== Влияние искажений на РЛИ <ref:NoCorr>
Рассмотрим эффекты, возникающие на промежуточных этапах обработки голограммы и на конечном изображений вследствие наличия ТН. Значения параметров модели приведены в /*@tab:*/. Координаты целей аналогичны предыдущему пункту /*@ref:NoDis*/ (см. /*tab*/). Значения амплитуды искажения траектории выбраны соответственно меньше, порядка и больше, чем размер ячейки изображения по дальности.

#figure(
  table(
    columns: (auto, auto),
    align: (right, left),
    table.header(
      [*Параметр*], [*Значение*],
    ),
    [$"res"_a$], [0,3 м],
    [$"res"_r$], [0,22 м],
    [$h$], [800 м],
    [$alpha$], [10#sym.degree],
    [$v$], [50 м/с],
    [$t_r$], [5 мкс],
    [_bw_], [600 МГц],
    [_prf_], [720 Гц],
    [$f_0$], [9,275 ГГц],
    [$y_0$], [$-1000 dot tan(alpha slash 2) $ м],
    [$R_"min"$], [2000 м],
    [$R_"max"$], [3800 м],
    [$T$], [3,5 с],
    [*_dis_x_ampl_*], [*варьируется*],
    [_dis_x_freq_], [$2 slash T$ Гц]
  ),
  caption : [Параметры симуляции]
)<tab:no_corr_model_params>

#figure(
  table(
    columns: (auto, auto),
    align: (right, left, left),
    table.header(
      [*Номер симуляции*], [_dis_x_ampl_, м]
    ),
    [1], [0,1],
    [2], [0.2],
    [3], [0.4],
  ),
  caption : [Значения варьируемых параметров, для которых проводились симуляции]
)<tab:no_corr_dis_x_ampl>

Сначала рассмотрим изменения на голограмме после применения операций ДДА на примере цели #2. Затем, для оценки влияния искажений детально рассмотрим голограмму после операции коррекции миграции дальности. Чтобы отобразить набег фазы, связанный с только искажением дальности, домножим строку голограммы на соответствующей дальности на $exp(-j dot 2 pi f_eta (- y_0/v))$. Приведённые в данном пункте изображения и графики будут затем использованы для оценки работы алгоритмов компенсации. На всех изображениях, где представлена голограмма, изображена её амплитуда, если не сказано иного.

=== Симуляция 1
На @fig:NoCorr_dR представлены искажения наклонных дальностей до целей, возникающих в результате траекторных отклонений. Аналогично п. /*@ref:NoDis*/ на @fig:NoCorr_fragments представлены фрагменты голограммы с выбранной целью после последовательного выполнения операций  алгоритма. Изображения демонстрируют, что цель по азимуту оказывается существенно размыта, а влияние искажений заметно на всех этапах формирования РЛИ.

 #figure(
    image("images/no_corr_sim1/NoCorr_dR.svg", width: 100%),
    caption: [Искажение наклонных дальностей до целей],
 )<fig:NoCorr_dR>

 #figure(
    table(
    columns: (auto, auto),
    stroke: none,
    align: (center, center),
    [#image("images/no_corr_sim1/NoCorr_pulse_compr.svg", width: 100%)],
    [#image("images/no_corr_sim1/NoCorr_azimuth_fft.svg", width: 100%)],
    [а)], [б)],
    [#image("images/no_corr_sim1/NoCorr_rcmc.svg", width: 100%)],
    [#image("images/no_corr_sim1/NoCorr_final.svg", width: 100%)],
    [в)], [г)],
    [#image("images/no_corr_sim1/NoCorr_azimuth_slice.svg", width: 120%)],
    [#image("images/no_corr_sim1/NoCorr_range_slice.svg", width: 120%)],
    [д)], [е)],
  ),
    caption: [Фрагменты голограммы после выполнения операций: сжатия по дальности (а), БПФ по азимуту (б), коррекции миграции дальности (в); Полученное изображение цели (г), его сечения по азимуту (д) и дальности (е).],
    kind: image,
  )<fig:NoCorr_fragments>

Рассмотрим подробнее голограмму после коррекции миграции дальности. На @fig:NoCorr_phase_rcmc, а) можно заметить, что набег фазы соответствует искажению траектории, показанном на @fig:NoCorr_dR. К изображению @fig:NoCorr_phase_rcmc, б) применён полосовой фильтр в диапазоне реальных доплеровских частот для центра изображения (элементы массива голограммы по азимуту соответствуют полосе частот _[-prf, +prf]_). Данное действие является частью алгоритма синтеза и используется для улучшения характеристик получаемых РЛИ. Также стоит отметить, что операция коррекция миграции дальности позволяет исправить искривления отклика цели вдоль оси азимута (в сравнении с искажениями на @fig:NoCorr_dR), но не набег фазы, который и вносит основной вклад в размытия РЛИ. Данный набег и предстоит убрать для исправления размытия РЛИ, т.е. должен остаться только линейный набег фазы. Далее в работе вид графика фазы на данном шаге будет использоваться для оценки качества работы процедур компенсации.

 #figure(
    table(
    columns: (auto, auto),
    stroke: none,
    align: (center, center),
    [#image("images/no_corr_sim1/NoCorr_phase_rcmc.svg", width: 100%)],
    [#image("images/no_corr_sim1/NoCorr_target_rcmc.svg", width: 100%)],
    [а)], [б)],
  ),
    caption: [Набег фазы для выбранной цели, связанный с искажениями траектории (а); Искажение отклика выбранной цели на голограмме (б)],
    kind: image,
 )<fig:NoCorr_phase_rcmc>

Приведём также полученные изображения всех целей (см. @fig:NoCorr_all_targets). Отчётливо видно, что даже искажение порядка половины размера ячейки изображения по дальности уже приводит к существенной расфокусировки РЛИ. Определение параметров функций отклика в данном случае не имеет смысла. 

 #figure(
    image("images/no_corr_sim1/NoCorr_all_targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )<fig:NoCorr_all_targets>

=== Симуляция 2
Проведём моделирование и анализ аналогично предыдущему подпункту.

 #figure(
    image("images/no_corr_sim2/NoCorr_dR.svg", width: 100%),
    caption: [Искажение наклонных дальностей до целей],
 )

 #figure(
    table(
    columns: (auto, auto),
    stroke: none,
    align: (center, center),
    [#image("images/no_corr_sim2/NoCorr_pulse_compr.svg", width: 100%)],
    [#image("images/no_corr_sim2/NoCorr_azimuth_fft.svg", width: 100%)],
    [а)], [б)],
    [#image("images/no_corr_sim2/NoCorr_rcmc.svg", width: 100%)],
    [#image("images/no_corr_sim2/NoCorr_final.svg", width: 100%)],
    [в)], [г)],
    [#image("images/no_corr_sim2/NoCorr_azimuth_slice.svg", width: 120%)],
    [#image("images/no_corr_sim2/NoCorr_range_slice.svg", width: 120%)],
    [д)], [е)],
  ),
    caption: [Фрагменты голограммы после выполнения операций: сжатия по дальности (а), БПФ по азимуту (б), коррекции миграции дальности (в); Полученное изображение цели (г), его сечения по азимуту (д) и дальности (е).],
    kind: image,
  )

 #figure(
    table(
    columns: (auto, auto),
    stroke: none,
    align: (center, center),
    [#image("images/no_corr_sim2/NoCorr_phase_rcmc.svg", width: 100%)],
    [#image("images/no_corr_sim2/NoCorr_target_rcmc.svg", width: 100%)],
    [а)], [б)],
  ),
    kind: image,
    caption: [Набег фазы для выбранной цели, связанный с искажениями траектории (а); Искажение отклика выбранной цели на голограмме (б)],
 )

 #figure(
    image("images/no_corr_sim2/NoCorr_all_targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )

=== Симуляция 3
Проведём моделирование и анализ аналогично предыдущему подпункту.

 #figure(
    image("images/no_corr_sim3/NoCorr_dR.svg", width: 100%),
    caption: [Искажение наклонных дальностей до целей],
 )

 #figure(
    table(
    columns: (auto, auto),
    stroke: none,
    align: (center, center),
    [#image("images/no_corr_sim3/NoCorr_pulse_compr.svg", width: 100%)],
    [#image("images/no_corr_sim3/NoCorr_azimuth_fft.svg", width: 100%)],
    [а)], [б)],
    [#image("images/no_corr_sim3/NoCorr_rcmc.svg", width: 100%)],
    [#image("images/no_corr_sim3/NoCorr_final.svg", width: 100%)],
    [в)], [г)],
    [#image("images/no_corr_sim3/NoCorr_azimuth_slice.svg", width: 120%)],
    [#image("images/no_corr_sim3/NoCorr_range_slice.svg", width: 120%)],
    [д)], [е)],
  ),
    caption: [Фрагменты голограммы после выполнения операций: сжатия по дальности (а), БПФ по азимуту (б), коррекции миграции дальности (в); Полученное изображение цели (г), его сечения по азимуту (д) и дальности (е).],
    kind: image,
  )

 #figure(
    table(
    columns: (auto, auto),
    stroke: none,
    align: (center, center),
    [#image("images/no_corr_sim3/NoCorr_phase_rcmc.svg", width: 100%)],
    [#image("images/no_corr_sim3/NoCorr_target_rcmc.svg", width: 100%)],
    [а)], [б)],
  ),
    kind: image,
    caption: [Набег фазы для выбранной цели, связанный с искажениями траектории (а); Искажение отклика выбранной цели на голограмме (б)],
 )

 #figure(
    image("images/no_corr_sim3/NoCorr_all_targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )

== Исследование алгоритмов компенсации <ref:CorrTest>
Значения параметров модели, координат целей и амплитуд искажений аналогичны предыдущем пунктам и приведены в /*@tab:*/. Теперь добавим процедуры компенсации ТН к модели и проведём аналогичные симуляции, чтобы сделать вывод о результатах работы алгоритмов.

=== "Точный" метод <ref:PreciseCorr>
=== Симуляция 1
В соответствии с описанной ранне процедурой построим графики набега фазы в отклике цели, вызванного траекторными отклонениями (@fig:PrCorr_phase_rcmc). В соответствии с процедурой алгоритма, описанной в гл. /*ref:phase_multi*/, набег для центральной цели был скомпенсирован полностью, на графике набега фазы виден постоянный набег, и на полученном РЛИ (@fig:PrCorr_all_targets) изображение данной цели полностью сфокусировано, о чём также говорят параметры в /*@tab:PrCorr_target_params*/: разрешение, относительный (PSLR) и интегральный (ISLR) уровень боковых лепестков по каждой из осей. Для остальных целей вид набега фазы в точности соответствует разнице законов изменения дальности для данной и центральной целей. Присутствующий шум на графиках может быть связан с некоторой неточностью определения сечения на голограмме.

 #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/prec_corr_sim1/PrCorr_phase_rcmc3.svg", width: 100%)],
    [#image("images/prec_corr_sim1/PrCorr_phase_rcmc1.svg", width: 100%)],
    [#image("images/prec_corr_sim1/PrCorr_phase_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Набег фазы для целей, связанный с искажениями траектории],
 )<fig:PrCorr_phase_rcmc>

 Рассмотрим теперь вид отклика на голограмме (@fig:PrCorr_target_rcmc). Отклики верхних и нижних целей выглядят обрезанными из-за применённого фильтра, о чём сказано в предыдущем пункте. На всех фрагментах отклик цели представляет прямую линию, т.е. эффект от искажения, связанный с ошибкой времени регистрации прихода импульса и, соответственно, дальности также был скомпенсирован. 

  #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/prec_corr_sim1/PrCorr_target_rcmc3.svg", width: 100%)],
    [#image("images/prec_corr_sim1/PrCorr_target_rcmc1.svg", width: 100%)],
    [#image("images/prec_corr_sim1/PrCorr_target_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Искажение отклика целей на голограмме],
 )<fig:PrCorr_target_rcmc>

Полученные РЛИ целей представлены на @fig:PrCorr_all_targets. В данной симуляции для использованной величины траекторных отклонений видимые искажения на РЛИ отсутствуют, все цели сфокусированы.

  #figure(
    image("images/prec_corr_sim1/PrCorr_all_targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )<fig:PrCorr_all_targets>

 Параметры функций отклика приведены в /*@tab:PrCorr_target_params*/: разрешение, относительный (PSLR) и интегральный (ISLR) уровень боковых лепестков по каждой из осей. Для данной симуляции полученные параметры несущественно отличаются от идеального случая, из чего можно сделать вывод о том, что ТН в целом были исправлены. Тем не менее, параметры целей получаются хуже в силу того, что данный метод полностью исправляет искажения только для одной цели, и остальные цели остаются частично дефокусированными.

 #figure(
   table(
     columns: (auto, ) + 6 * (1fr,),
     align: center,
     fill: (x, y) => if y <= 1 { blue.lighten(90%) },
     [], table.cell(colspan: 3, [*Азимут*]), table.cell(colspan: 3, [*Дальность*], ),
     [№], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*],
     ..csv("data/PrCorr_params_sim1.csv").flatten().map(float).map((x) => if calc.abs(x) < 1 { calc.round(x, digits: 2) } else { calc.round(x, digits: 1)}).map(str).map((s) => s.replace(".", ","))
   ),
   caption: [Параметры функций отклика полученных РЛИ целей]
 )<tab:PrCorr_target_params>

=== Симуляция 2
Проведём аналогичный анализ для остальных симуляций. На графиках набега фазы и амплитуды отклика наблюдается аналогичная картина, как и в предыдущем случае. Однако, ввиду повышения амплитуды ТН увеличивается величина остаточного набега для остальных целей, что ведёт к дальнейшему ухудшению получаемых изображений.

 #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/prec_corr_sim2/PrCorr_phase_rcmc3.svg", width: 100%)],
    [#image("images/prec_corr_sim2/PrCorr_phase_rcmc1.svg", width: 100%)],
    [#image("images/prec_corr_sim2/PrCorr_phase_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Набег фазы для целей, связанный с искажениями траектории],
 )

  #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/prec_corr_sim2/PrCorr_target_rcmc3.svg", width: 100%)],
    [#image("images/prec_corr_sim2/PrCorr_target_rcmc1.svg", width: 100%)],
    [#image("images/prec_corr_sim2/PrCorr_target_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Искажение отклика целей на голограмме],
 )

  #figure(
    image("images/prec_corr_sim2/PrCorr_all_targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )

 #figure(
   table(
     columns: (auto, ) + 6 * (1fr,),
     align: center,
     fill: (x, y) => if y <= 1 { blue.lighten(90%) },
     [], table.cell(colspan: 3, [*Азимут*]), table.cell(colspan: 3, [*Дальность*], ),
     [№], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*],
     ..csv("data/PrCorr_params_sim2.csv").flatten().map(float).map((x) => if calc.abs(x) < 1 { calc.round(x, digits: 2) } else { calc.round(x, digits: 1)}).map(str).map((s) => s.replace(".", ","))
   ),
   caption: [Параметры функций отклика полученных РЛИ целей]
 )

=== Симуляция 3
При дальнейшем увеличении амплитуды искажения траектории остаточный набег фазы уже вызывает существенное размытия изображений, что можно наблюдать на соответствующих графиках и в таблице параметров откликов целей. Тем не менее, в соответствии со описанием работы алгоритма, центральная цель остаётся полностью сфокусированной.

 #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/prec_corr_sim3/PrCorr_phase_rcmc3.svg", width: 100%)],
    [#image("images/prec_corr_sim3/PrCorr_phase_rcmc1.svg", width: 100%)],
    [#image("images/prec_corr_sim3/PrCorr_phase_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Набег фазы для целей, связанный с искажениями траектории],
 )

  #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/prec_corr_sim3/PrCorr_target_rcmc3.svg", width: 100%)],
    [#image("images/prec_corr_sim3/PrCorr_target_rcmc1.svg", width: 100%)],
    [#image("images/prec_corr_sim3/PrCorr_target_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Искажение отклика целей на голограмме],
 )

  #figure(
    image("images/prec_corr_sim3/PrCorr_all_targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )

 #figure(
   table(
     columns: (auto, ) + 6 * (1fr,),
     align: center,
     fill: (x, y) => if y <= 1 { blue.lighten(90%) },
     [], table.cell(colspan: 3, [*Азимут*]), table.cell(colspan: 3, [*Дальность*], ),
     [№], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*],
     ..csv("data/PrCorr_params_sim3.csv").flatten().map(float).map((x) => if calc.abs(x) < 1 { calc.round(x, digits: 2) } else { calc.round(x, digits: 1)}).map(str).map((s) => s.replace(".", ","))
   ),
   caption: [Параметры функций отклика полученных РЛИ целей]
 )

=== "Приближённый" метод <ref:ApproxCorr>
=== Симуляция 1
Для "приближённого" метода компенсации траекторных отклонений проведём аналогичные исследования. Как было сказано в /*@ref:phase_multi*/, в данном методе для исправления ТН используются только фазовые множители, применение которых нацелено на коррекцию искажений в равной степени для всех целей в зависимости от их наклонной дальности. Ввиду этого остаточный набег фазы имеется у всех целей, как показано на @fig:ApCorr_phase_rcmc. 

 #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/appr_corr_sim1/ApCorr_phase_rcmc3.svg", width: 100%)],
    [#image("images/appr_corr_sim1/ApCorr_phase_rcmc1.svg", width: 100%)],
    [#image("images/appr_corr_sim1/ApCorr_phase_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Набег фазы для целей, связанный с искажениями траектории],
 )<fig:ApCorr_phase_rcmc>

 Отклики целей на соответствующих фрагментах голограммы для данной величины амплитуды отклонений (@fig:ApCorr_target_rcmc) не обнаруживают их влияния. Однако, ввиду того, что данный метод не компенсирует ошибку времени регистрации отражённого сигнала цели, в дальнейшем при увеличении амплитуды искажений их влияние будет проявляться более отчётливо.

  #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/appr_corr_sim1/ApCorr_target_rcmc3.svg", width: 100%)],
    [#image("images/appr_corr_sim1/ApCorr_target_rcmc1.svg", width: 100%)],
    [#image("images/appr_corr_sim1/ApCorr_target_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Искажение отклика целей на голограмме],
 )<fig:ApCorr_target_rcmc>

На полученных РЛИ целей существенные искажения отсутствуют, в данной симуляции все цели сфокусированы.

  #figure(
    image("images/appr_corr_sim1/ApCorr_all_targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )<fig:ApCorr_all_targets>

 В /*@tab:ApCorr_target_params*/ приведены параметры функций отклика целей. Для данной симуляции, как и в случае "точного" метода, полученные параметры несущественно отличаются от идеального случая, т.е. ТН в целом были исправлены. Тем не менее, параметры целей получаются хуже в силу того, что данный метод не исправляет фазовые искажения полностью, а ошибка времени регистрации в процедуре компенсации не исправляется вовсе, однако в данном случае для её исправления хватает операции коррекции миграции дальности ДДА. В дальнейшем это также будет вносить вклад в ухудшения изображения.

 #figure(
   table(
     columns: (auto, ) + 6 * (1fr,),
     align: center,
     fill: (x, y) => if y <= 1 { blue.lighten(90%) },
     [], table.cell(colspan: 3, [*Азимут*]), table.cell(colspan: 3, [*Дальность*], ),
     [№], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*],
     ..csv("data/ApCorr_params_sim1.csv").flatten().map(float).map((x) => if calc.abs(x) < 1 { calc.round(x, digits: 2) } else { calc.round(x, digits: 1)}).map(str).map((s) => s.replace(".", ","))
   ),
   caption: [Параметры функций отклика полученных РЛИ целей]
 )<tab:ApCorr_target_params>

=== Симуляция 2
Увеличим амплитуду ТН и проведём аналогичные исследования. В данной симуляции имеем аналогичный вид набега фазы и отклика цели на голограмме. Однако изображения всех целей начинают портиться сильнее, чем для аналогичной компенсации "точным" методом, наблюдается существенное размытие.

 #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/appr_corr_sim2/ApCorr_phase_rcmc3.svg", width: 100%)],
    [#image("images/appr_corr_sim2/ApCorr_phase_rcmc1.svg", width: 100%)],
    [#image("images/appr_corr_sim2/ApCorr_phase_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Набег фазы для целей, связанный с искажениями траектории],
 )

  #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/appr_corr_sim2/ApCorr_target_rcmc3.svg", width: 100%)],
    [#image("images/appr_corr_sim2/ApCorr_target_rcmc1.svg", width: 100%)],
    [#image("images/appr_corr_sim2/ApCorr_target_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Искажение отклика целей на голограмме],
 )

  #figure(
    image("images/appr_corr_sim2/ApCorr_all_targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )

 #figure(
   table(
     columns: (auto, ) + 6 * (1fr,),
     align: center,
     fill: (x, y) => if y <= 1 { blue.lighten(90%) },
     [], table.cell(colspan: 3, [*Азимут*]), table.cell(colspan: 3, [*Дальность*], ),
     [№], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*],
     ..csv("data/ApCorr_params_sim2.csv").flatten().map(float).map((x) => if calc.abs(x) < 1 { calc.round(x, digits: 2) } else { calc.round(x, digits: 1)}).map(str).map((s) => s.replace(".", ","))
   ),
   caption: [Параметры функций отклика полученных РЛИ целей]
 )

=== Симуляция 3
При дальнейшем увеличении амплитуды искажений изображения всех целей продолжают ухудшаться, однако полного разрушения РЛИ (как в случае отсутствия компенсации) не происходит. Следовательно, данный метод при всех моделируемых величинах отклонений в целом справляется с их компенсации, при этом качество изображений боковых целей оказывается выше, чем при компенсации "точным" методом.

 #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/appr_corr_sim3/ApCorr_phase_rcmc3.svg", width: 100%)],
    [#image("images/appr_corr_sim3/ApCorr_phase_rcmc1.svg", width: 100%)],
    [#image("images/appr_corr_sim3/ApCorr_phase_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Набег фазы для целей, связанный с искажениями траектории],
 )

  #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/appr_corr_sim3/ApCorr_target_rcmc3.svg", width: 100%)],
    [#image("images/appr_corr_sim3/ApCorr_target_rcmc1.svg", width: 100%)],
    [#image("images/appr_corr_sim3/ApCorr_target_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Искажение отклика целей на голограмме],
 )

  #figure(
    image("images/appr_corr_sim3/ApCorr_all_targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )

 #figure(
   table(
     columns: (auto, ) + 6 * (1fr,),
     align: center,
     fill: (x, y) => if y <= 1 { blue.lighten(90%) },
     [], table.cell(colspan: 3, [*Азимут*]), table.cell(colspan: 3, [*Дальность*], ),
     [№], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*],
     ..csv("data/ApCorr_params_sim3.csv").flatten().map(float).map((x) => if calc.abs(x) < 1 { calc.round(x, digits: 2) } else { calc.round(x, digits: 1)}).map(str).map((s) => s.replace(".", ","))
   ),
   caption: [Параметры функций отклика полученных РЛИ целей]
 )

== Компенсация искажений при больших ТН
Отдельно промоделируем работу алгоритмов компенсации при траекторных отклонениях на порядок больше размера ячейки РЛИ по дальности, т.е. *_dis_x_ampl = 4 м_*. Остальные параметры оставим без изменения. Сначала рассмотрим влияние искажений, затем их компенсацию обоими методами.

=== Симуляция без компенсации ТН
Аналогично предыдущим пунктам, рассмотрим соответствующие этапы синтеза РЛИ. На @fig:NoCorr_dR_big приведены графики искажения наклонных дальностей, результат которых модно наблюдать на этапах синтеза из @fig:NoCorr_fragments_big и полученных РЛИ целей  @fig:NoCorr_all_targets_big в виде полного разрушения изображений. На фрагменте @fig:NoCorr_phase_rcmc_big для цели #2 обратим внимание, что её отклик уже не близок к прямой линии, а оказывается существенно искривлён.

#figure(
    image("images/no_corr_big/NoCorr_dR.svg", width: 100%),
    caption: [Искажение наклонных дальностей до целей],
 )<fig:NoCorr_dR_big>

 #figure(
    table(
    columns: (auto, auto),
    stroke: none,
    align: (center, center),
    [#image("images/no_corr_big/NoCorr_pulse_compr.svg", width: 100%)],
    [#image("images/no_corr_big/NoCorr_azimuth_fft.svg", width: 100%)],
    [а)], [б)],
    [#image("images/no_corr_big/NoCorr_rcmc.svg", width: 100%)],
    [#image("images/no_corr_big/NoCorr_final.svg", width: 100%)],
    [в)], [г)],
    [#image("images/no_corr_big/NoCorr_azimuth_slice.svg", width: 120%)],
    [#image("images/no_corr_big/NoCorr_range_slice.svg", width: 120%)],
    [д)], [е)],
  ),
    caption: [Фрагменты голограммы после выполнения операций: сжатия по дальности (а), БПФ по азимуту (б), коррекции миграции дальности (в); Полученное изображение цели (г), его сечения по азимуту (д) и дальности (е).],
    kind: image,
  )<fig:NoCorr_fragments_big>

 #figure(
    table(
    columns: (auto, auto),
    stroke: none,
    align: (center, center),
    [#image("images/no_corr_big/NoCorr_phase_rcmc.svg", width: 100%)],
    [#image("images/no_corr_big/NoCorr_target_rcmc.svg", width: 100%)],
    [а)], [б)],
  ),
    kind: image,
    caption: [Набег фазы для выбранной цели, связанный с искажениями траектории (а); Искажение отклика выбранной цели на голограмме (б)],
 )<fig:NoCorr_phase_rcmc_big>

 #figure(
    image("images/no_corr_big/NoCorr_all_targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )<fig:NoCorr_all_targets_big>

=== Компенсация "точным" методом
Применим "точный" метод для компенсации искажений. В соответствии с процедурой алгоритма, центральная цель полностью избавлена от искажений (@fig:PrCorr_phase_rcmc_big). Цели на аналогичной ей дальности частично дефокусированы. Остаточное искажение для остальных целей оказывается настолько велико, что их изображения разрушены (@fig:PrCorr_all_targets_big). Отметим также, что благодаря компенсации ошибки времени регистрации отклика цели, амплитуда откликов (@fig:PrCorr_target_rcmc_big) практически полностью выпрямляется, что вносит вклад в компенсацию отклонений.

#figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/prec_corr_big/PrCorr_phase_rcmc3.svg", width: 100%)],
    [#image("images/prec_corr_big/PrCorr_phase_rcmc1.svg", width: 100%)],
    [#image("images/prec_corr_big/PrCorr_phase_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Набег фазы для целей, связанный с искажениями траектории],
 )<fig:PrCorr_phase_rcmc_big>

  #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/prec_corr_big/PrCorr_target_rcmc3.svg", width: 100%)],
    [#image("images/prec_corr_big/PrCorr_target_rcmc1.svg", width: 100%)],
    [#image("images/prec_corr_big/PrCorr_target_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Искажение отклика целей на голограмме],
 )<fig:PrCorr_target_rcmc_big>

  #figure(
    image("images/prec_corr_big/PrCorr_all_targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )<fig:PrCorr_all_targets_big>

 #figure(
   table(
     columns: (auto, ) + 6 * (1fr,),
     align: center,
     fill: (x, y) => if y <= 1 { blue.lighten(90%) },
     [], table.cell(colspan: 3, [*Азимут*]), table.cell(colspan: 3, [*Дальность*], ),
     [№], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*],
     ..csv("data/PrCorr_params_big.csv").flatten().map(float).map((x) => if calc.abs(x) < 1 { calc.round(x, digits: 2) } else { calc.round(x, digits: 1)}).map(str).map((s) => s.replace(".", ","))
   ),
   caption: [Параметры функций отклика полученных РЛИ целей]
 )<tab:PrCorr_target_params_big>

 === Компенсация "приближённым" методом
В отличие от предыдущего пункта, "приближённому" методу не удаётся справиться с ТН. Существенный статочный набег фазы (@fig:ApCorr_phase_rcmc_big) и искривление амплитуды отклика (@fig:ApCorr_target_rcmc_big), вызванное существенно большей ошибкой времени регистрации приводят к тому, что РЛИ всех целей оказываются разрушены, что показано на @fig:ApCorr_all_targets_big.

#figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/appr_corr_big/ApCorr_phase_rcmc3.svg", width: 100%)],
    [#image("images/appr_corr_big/ApCorr_phase_rcmc1.svg", width: 100%)],
    [#image("images/appr_corr_big/ApCorr_phase_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Набег фазы для целей, связанный с искажениями траектории],
 )<fig:ApCorr_phase_rcmc_big>

  #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/appr_corr_big/ApCorr_target_rcmc3.svg", width: 100%)],
    [#image("images/appr_corr_big/ApCorr_target_rcmc1.svg", width: 100%)],
    [#image("images/appr_corr_big/ApCorr_target_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Искажение отклика целей на голограмме],
 )<fig:ApCorr_target_rcmc_big>

  #figure(
    image("images/appr_corr_big/ApCorr_all_targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )<fig:ApCorr_all_targets_big>

 #figure(
   table(
     columns: (auto, ) + 6 * (1fr,),
     align: center,
     fill: (x, y) => if y <= 1 { blue.lighten(90%) },
     [], table.cell(colspan: 3, [*Азимут*]), table.cell(colspan: 3, [*Дальность*], ),
     [№], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*],
     ..csv("data/ApCorr_params_big.csv").flatten().map(float).map((x) => if calc.abs(x) < 1 { calc.round(x, digits: 2) } else { calc.round(x, digits: 1)}).map(str).map((s) => s.replace(".", ","))
   ),
   caption: [Параметры функций отклика полученных РЛИ целей]
 )<tab:ApCorr_target_params_big>

== Вывод
 Здесь будет большой вывод обо всё происходящем.