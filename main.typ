#import "diploma.typ": diploma

#import "@preview/cetz:0.3.4": canvas, draw
#import "@preview/cetz-plot:0.1.1": plot

#show: doc => diploma(doc)
#set text(lang: "ru")

= Программная реализация алгоритмов компенсации траекторных отклонений для синтеза радиолокационных изображений

= Список сокращений

#let abbr = (
  (name: "РСА", desc: "радиолокатор с синтезированной апертурой"),
  (name: "ТН",  desc: "траекторные нестабильности"),
  (name: "РЛИ", desc: "радиолакационное изображение"),
  (name: "РЛС", desc: "радиолакационная станция"),
  (name: "ГНСС", desc: "глобальная навигационная спутниковая система"),
  (name: "БПФ", desc: "быстрое преобразование Фурье"),
  (name: "ДН",  desc: "диаграмма направленности"),
  (name: "ДЗЗ",  desc: "дистанционное зондирование Земли"),
  (name: "ЛЧМ",  desc: "линейная частотная модуляция"),
  (name: "БИНС",  desc: "бортовая инерциальная навигационная система"),
  (name: "ЦОС",  desc: "цифровая обработка сигналов"),
)

#table(
  columns: (1fr, 5fr),
  stroke: none,
  ..abbr.sorted(key: it => it.name).map(it => (it.name, "-" + "     " + it.desc).flatten()).flatten()
)

#pagebreak()

= Аннотация
Радиолокационное синтезирование апертуры является одной из ведущих технологий дистанционного зондирования, позволяющей получать детальные изображения земной и водной поверхности вне зависимости от погодных условий. Радиолокаторы с синтезированной апертурой (РСА) являются активными средствами наблюдения, т.е. используют облучение пространства зондирующим сигналом, приём и обработку отражённых сигналов. Полученные голограммы затем позволяют синтезировать радиолокационные изображения, содержащие информацию о свойствах объекта наблюдения. 

Основное отличие синтезированной апертуры от реальной заключается в том, что синтезированная апертура формируется последовательно во времени, при этом каждый момент времени приём сигнала производится реальной апертурой. Синтезирование апертуры осуществляется за счёт приёма сигнала реальной апертурой при различном её положении относительно источника. В каждом положении РЛС излучает зондирующей импульс и принимает его отражение от точечной цели (или земной поверхности). Параметры принятого сигнала --- амплитуда и фаза записываются в запоминающее устройство и затем подвергается обработке различными алгоритмами для, непосредственно, синтеза изображения. Такой метод позволяет получить апертуру большого размера, используя антенну малого размера, и, как следствие, большее линейное разрешение.

Таким образом, радиолокационная съёмка обладает рядом преимуществ в сравнении с оптическими средствами наблюдения [Верба]:
- Независимость от метеорологических условий и освещённости.
- Повышенная точность измерения геометрических характеристик объектов.
- Возможность построения карт рельефа.
- Возможность определения диэлектрических, динамических характеристик объектов наблюдения.
- Возможность наблюдения объектов, невидимых в оптическом и ИК-диапазонах, например, скрытых снежным или растительным покровом.
- Возможность получения дополнительной информации об объектах на основании их электродинамических свойств.
Однако, системы РСА имеют ряд ограничений:
- Малая длительность наблюдения цели --- менее чем единицы минут в зависимости от режима работы, большие интервалы повторной съёмки (характерно для РСА космического базирования).
- Существенные геометрические искажения и размытие РЛИ, вызванные нестабильным и неравномерным движением платформы-носителя (характерно для РСА авиационного базирования).
- Опасность подавления РСА путём создания мощной помехи.
Вышеописанные особенности систем РСА позволяют использовать их в различных отраслях ДЗЗ. В настоящее время системы аэрокосмического мониторинга на базе РСА используются для решения следующих задач: 
- Всепогодное слежение за земной и водной поверхностью.
- Построение цифровых моделей рельефа.
- Прогнозирование глобальных природных процессов
- Поиск и идентификация объектов
- Контроль состояния объектов путём отслеживания их электродинамических свойств или геометрических характеристик

Одним из вариантов исполнения системы РСА является РСА авиационного базирования. Такой вариант обладает некоторыми важными преимуществами перед РСА космического базирования. В первую очередь, авиационные РСА обладают большей мобильностью, т.е. траектория носителя РСА может иметь практически любую геометрию, что позволяет использовать различные режимы работа в зависимости от задачи. Также немаловажно, что разработка и развёртывание таких систем может быть значительно проще и быстрее, что существенно повышает оперативность решения задач наблюдения. 

Однако, РСА авиационного базирования обладают существенным недостатком: траектория движения носителя такой системы подвержена существенным искажениям относительно идеального равномерного и прямолинейного движения, вызванным флуктуациями и другими процессами, происходящими в атмосфере. Такие траекторные нестабильности (ТН) приводят к геометрическим искажениям и размытию получаемых РЛИ. Вследствие этого, становится актуальной задача компенсации ТН при синтезе изображений. Традиционным способом решения данной проблемы является дополнительная процедура автофокусировки изображения (оценка оптимальных параметров синтеза), которая существенно увеличивает вычислительную нагрузку и приводит к потере радиометрических и геометрических характеристик. Микроминиатюризация, усовершенствование инерциальных датчиков и высокоточных средств определения положения с помощью ГНСС (до нескольких сантиметров) позволяют в данный момент получать точную информацию о положении и ориентации носителя РСА во время съемки и учитывать ее для компенсации траекторных искажений. Преимуществом данного подхода является возможность избежать процедуры автофокусировки путём корректировки существующих алгоритмов синтеза изображений с сохранением радиометрических и геометрических характеристик РЛИ. Таким образом, целью данной работы является реализация вышеописанной процедуры компенсации ТН для дальностно-доплеровского алгоритма, анализ качества реализации на модельных радиолокационных и навигационных данных и верификация с использованием реальных данных самолётного РСА. Обоснование выбора данного алгоритма и подходов к компенсации ТН приведено далее.

== Схема работы РСА
Геометрия радиолокационного обзора представлена на рисунке @fig:sar_geometry. По мере движения платформы, на которую установлена радиолокационная система, радар периодически излучает сигнал, после чего регистрирует его отражение от поверхности. ДН антенной системы направлена в сторону от траектории движения, в некоторых системах это направление не перпендикулярно ей, т.е. имеет место _угол скоса_.

Существуют различные режимы работы систем РСА, наиболее распространённые из них:
- _Маршрутный режим_ --- непрерывная съёмка фиксированной полосы вдоль трассы полёта.
- _Прожекторный режим_ --- направление ДН антенны непрерывно подстраивается для съёмки определённой точки поверхности.
- _Обзорный режим_ --- увеличение ширины полосы съёмки путём использования нескольких лучей

В данной работе рассматривается РСА в маршрутном режиме работы при нулевом угле скоса.

 #figure(
    image("images/SAR_geometry.svg", width: 70%), // линии из ФЦ, заглавные буквы
    caption: [Геометрия работы РСА],
  )<fig:sar_geometry> 

Циклограмма сигнала, излучаемого и принимаемого антенной системой РСА, изображена на рисунке @fig:recv_signal. В начале периода излучается сигнал $t_r$. Затем аппаратура переключается на приём. Принятый сигнал записывается с момента $t_1$ (соответствующего началу прихода отражённого сигнала от объектов на ближней границе $R_1$), до момента $t_2$ (соответствующего окончанию прихода отражённого сигнала от объектов на дальней границе $R_2$). Описанный период повторяется с интервалом _PRI_.

  #figure(
    image("images/recv_signal.svg", width: 70%),
    caption: [Циклограмма излучения и приёма сигнала РСА], // отметить t_r, t_2=t_2+t_r, опечатка
  )<fig:recv_signal>

== Постановка задачи
 Как было сказано выше, одной из проблем, возникающих при синтезе изображения, полученного с РСА, является необходимость точного знания фазы траекторного сигнала, что равносильно ошибке положения точек апертуры относительно заданного. Эта необходимость обусловлена тем, что существующие алгоритмы синтеза РЛИ, как правило, предполагают равномерное прямолинейное движение платформы РСА. Одной из основных причин возникновения этих ошибок являются траекторные нестабильности платформы РСА, которые особенно характерны для РСА авиационного базирования. Допустимая ошибка в знании траектории фазового центра антенны составляет несколько миллиметров для сантиметрового диапазона волн. Этим обусловлена необходимость использования специальных алгоритмов компенсации траекторных нестабильностей.

 Таким образом, при реализации данных алгоритмов были сформулированы следующие задачи:
 - Реализовать и внедрить процедуру компенсации траекторных отклонений в дальностно-доплеровском алгоритма синтеза для изображений РСА самолетного базирования.
 - Провести анализ качества реализованных алгоритмов коррекции траекторных искажений по модельным радиолокационным и навигационным данным.
 - По результатам анализа сделать вывод о требованиях к точности навигационной информации для обеспечения заданных характеристик радиолокационных изображений (РЛИ).
- Верифицировать алгоритмы с использованием реальной навигационной информации при синтезе РЛИ экспериментального самолетного РСА X-диапазона.

План работы ...

== А
== Б
== В

= Алгоритмы синтеза РЛИ и коррекции ТН

== Дальностно-доплеровский алгоритм <ref:RDA>
Дальностно-доплеровский алгоритм разработан в 1978 году и является одним из наиболее распространённых алгоритмов синтеза РЛИ. Схема алгоритма с модификациями для коррекции ТН (будут рассмотрены далее) показана на рисунке @fig:RDA_model. Отличительной особенностью алгоритма является операция коррекции миграции дальности, которая выполняется во временной области по дальности и в частотной области по азимуту (области доплеровских частот). 

  #figure(
    image("images/RDA_model.svg", width: 100%),
    caption: [Блок-схема алгоритма ДДА],
  )<fig:RDA_model>

Далее рассматриваются математические преобразования, осуществляемые на каждом шаге. Сигнал, отражённый от точечной цели после демодуляции, имеет вид:

#set math.equation(number-align: end + top)

$ s_0(tau, eta) &= \
& A_0 times && dash.em quad "некоторая константа" \
& times omega_r (tau - 2R(eta) slash c) && dash.em quad "огибающая по дальности (прямоуг.)" \ 
& times omega_a (eta - eta_c) && dash.em quad "огибающая по азимуту" (~sinc^2) \
& times exp(-j dot 4pi f_0 R(eta) slash c) && dash.em quad "остаточная фаза несущей" \
& times exp(j dot pi K_r (tau - 2R(eta) slash c)^2) quad && dash.em quad "фаза ЛЧМ импульса," $<eq:raw_signal>

$"где" quad &tau && dash.em quad "время по дальности (быстрое)" \
&eta && dash.em quad "время по азимуту (медленное)" \
&f_0 && dash.em quad "частота несущей" \
&K_r && dash.em quad "скорость ЛЧ-модуляции" \
&R(eta) quad && dash.em quad "наклонная дальность"$ // ref to eq

Величина $eta_c$ обозначает момент по оси "медленного" времени, когда доплеровская частота для данной цели равна нулю. Наклонная дальность определяется соотношением 
$ R(eta) = sqrt(R_0^2 + v_r^2eta^2), $<eq:slant_range>
где $R_0$ --- дальность ближайшего подлёта (см. рисунок @fig:sar_geometry), а $eta = 0$ в момент ближайшего подлёта к данной цели (для нескольких целей $eta$ обозначает абсолютное время, и $eta = 0$ в центре изображения).

=== Сжатие сигнала по дальности
Производится путём умножения ПФ по дальности исходного сигнала @eq:raw_signal на согласованный фильтр, представляющий из себя комплексно сопряжённое ПФ дополненного нулями единичного ЛЧМ-импульса длительностью $t_r$ (см. рисунок @fig:recv_signal)
$ g(tau) = exp(j dot pi K_r tau^2), quad {-t_r slash 2 < tau < t_r slash 2}, $ и взятия ОПФ по дальности полученного произведения. Полученное преобразование записывается как:
$ s_(r c) (tau, eta) &= "IFFT"_tau { "FFT"_tau [ s_0 (tau, eta) ] times "FFT"_tau [ g (tau) ]^* } = \
&= A_0 dot p_r (tau - 2R(eta) slash c) dot omega_a (eta - eta_c) dot exp(-j dot 4pi f_0 R(eta) slash c), $<eq:after_rc>
где $p_r (tau)$ --- функция $~sinc$. В результате данного преобразования из сигнала была исключена квадратичная по $tau$ компонента фазы.

=== БПФ по азимуту
Переводит голограмму в частотную (доплеровскую) область по этой оси. Для малых углов скоса можно воспользоваться приближением @eq:slant_range:
$ R(eta) = sqrt(R_0^2 + v_r^2eta^2) approx R_0 + (v_r^2 eta^2)/(2 R_0). $<eq:slant_range_approx>
Тогда /*eq:after_rc>*/ можно представить в виде
$ s_(r c) (tau, eta) &approx \
&approx A_0 dot p_r (tau - (2R(eta)) / c) dot omega_a (eta - eta_c) dot exp(-j (4pi f_0 R_0) / c) dot exp(-j pi (2 v_r^2)/(lambda R_0) eta^2) $<eq:rc_approx>
Последний множитель имеет квадратичную по $eta$ фазу (как у ЛЧМ-импульса), поэтому можно ввести скорость ЛЧ-модуляции по азимуту $ K_a approx (2 v_r^2)/(lambda R_0) $<eq:K_a>
Из ПСФ получаем $ f_eta = -K_a eta $<eq:POSP_f_eta>
Подставляя $eta = -f_eta slash K_a$ в @eq:rc_approx, после БПФ по азимуту получаем
$ S_1 (tau, f_eta) &= "FFT"_eta [s_(r c) (tau, eta)] = \
&= A_0 dot p_r (tau - (2R_(r d) (f_eta)) / c) dot W_a (f_eta - f_eta_c) dot exp(-j (4pi f_0 R_0) / c) dot exp(j pi f_eta^2 / K_a) $<eq:after_fft_eta>
Выражение @eq:slant_range_approx с учётом @eq:POSP_f_eta теперь может быть преобразовано как
$ R_(r d) (f_eta) approx R_0 + v_r^2/(2R_0) (f_eta / K_a)^2 = R_0 + (lambda^2 R_0 f_eta^2) / (8 v_r^2) $<eq:slant_range_approx_f_eta>

=== Вторичное сжатие по дальности
Выполняется путём умножения на согласованный фильтр в частотно-доплеровской области для того, чтобы уменьшить искажения, связанные с взаимозависимостью дальности и азимута друг от друга. В вышеописанных формулах эта зависимость опущена для упрощения, вывод же более точных соотношений весьма громоздкий и здесь не приводится.

=== Коррекция миграции дальности
Производится путём интерполяции в частотной по дальности и азимуту области. Из @eq:slant_range_approx_f_eta получаем $ R_(r d) (f_eta) = R_0 (1 + (lambda^2 f_eta^2) / (8 v_r^2)), $ т.е. миграция дальности происходит за счёт умножения на зависящий от $f_eta$ коэффициент. Интерполяция на новую дальность сигнала после предыдущего шага позволяет избавиться от этого множителя, в итоге получаем
$ S_2 (tau, f_eta) &= \
&= A_0 dot p_r (tau - (2R_0) / c) dot W_a (f_eta - f_eta_c) dot exp(-j (4pi f_0 R_0) / c) dot exp(j pi f_eta^2 / K_a) $<eq:after_rcmc>

=== Сжатие по азимуту
Выполняется путём умножения на согласованный фильтр такой, чтобы исключить квадратичную по $f_eta$ компоненту фазы. Такой фильтр имеет вид 
$ H_("az") (f_eta) = exp(-j pi f_eta^2/K_a) $<eq:az_compr_filt>
Полученный после умножения сигнал
$ S_3 (tau, f_eta) &= S_2 (tau, f_eta) times H_("az") (f_eta) = \
&= A_0 dot p_r (tau - (2R_0) / c) dot W_a (f_eta - f_eta_c) dot exp(-j (4pi f_0 R_0) / c) $<eq:after_ac>

=== ОБПФ по азимуту
В итоге после финальной операции сигнал имеет вид
$ s_(a c) (tau, eta) &= "IFFT"_eta [S_3 (tau, f_eta)] = \
&= A_0 dot p_r (tau - (2R_0) / c) dot p_a (eta) dot exp(-j (4pi f_0 R_0) / c) exp(j space 2pi f_eta_c eta), $
где $p_a (eta)$ --- функция $~sinc$. Таким образом, координаты цели теперь соответствуют #box[$tau = 2R_0 slash c$ и $eta = 0$].

#set math.equation(number-align: end + horizon)



Для синтеза РЛИ выбран дальностно-доплеровский алгоритм как наиболее простой в реализации, а также позволяющий проводить контроль промежуточных этапов обработки.

== Компенсация траекторных нестабильностей
Для РСА авиационного базирования траекторные искажения вносят существенную фазовую ошибку (в сравнении с длиной волны в единицы см), вызывая разрушения РЛИ. Следствиями фазовых искажений при синтезе РЛИ являются: 
- Смещение максимума, что приводит к ошибкам измерения координат объектов
- Уменьшение максимума выходного сигнала, что равносильно снижению энергетического потенциала РЛС
- Расширения главного лепестка отклика точечной цели, что приводит к ухудшению разрешающей способности
- Увеличение уровня мощности боковых лепестков отклика цели, что снижает контраст РЛИ
Существуют различные подходы к компенсации ТН, далее рассмотрены наиболее распространённые из них.

== Автофокусировка
//кондратенков
Поскольку для обеспечения высокой разрешающей способности РСА по азимуту необходимо с точностью до долей волны знать изменение траектории движения фазового центра антенны РСА на интервале синтезирования, требования по точности к БИНС носителя РСА должны быть достаточно высокими, что часто не выполняется. Тогда для высокоточного измерения фазовых искажений используется подход, основанный на использовании информации о фазовых нестабильностях, содержащейся в самой голограмме или РЛИ. При таком методе имеется также возможность компенсации фазовых искажений, вызванных не только ТН, но и нестабильностями аппаратуры РСА и среды распространения радиоволн. Такой процесс извлечения информации о фазовых искажениях из голограммы или самого РЛИ и компенсации этих искажений называется _автофокусировка_ и обычно используется для повышения резкости изображения.

В общем случае процесс автофокусировки изображения включает два этапа:
+ оценка фазовой ошибки
+ компенсация фазовой ошибки

Второй этап включает:
- расчёт опорной функции, компенсирующей траекторные нестабильности. Фаза этой функции равна оценённой на 1 этапе фазовой ошибке, взятой с обратным знаком;
- умножение траекторного сигнала на опорную функцию;
- обработку исправленных с помощью алгоритма синтеза для формирования РЛИ.

Методы автофокусировки можно разделить на две группы:
- Методы, использующие мощные сигналы точечных отражателей как ориентиры.
- Методы, использующие траекторный сигнал от всех объектов и фона местности в диаграмме направленности антенны.

Далее рассмотрены несколько реализаций алгоритма автофокусировки. 

=== Фазово-градиентная автофокусировка
Квадратичное (по времени) слагаемое в степенном ряду фазовой ошибки влияет в основном на расфокусировку РЛИ, с приводит к ухудшению разрешения и снижению резкости изображения. Блок-схема алгоритма приведена на рисунке @fig:PGA_model. Данный алгоритм использует траекторный сигнал от всей поверхности, а появление сигнала от точечного отражателя только улучшит оценку фазовой ошибки. Вычисление слагаемых фазовой ошибки более высокого порядка может быть затруднено в связи с ухудшением радиометрических характеристик изображения при уменьшении длительности подапертур.

  #figure(
    image("images/PGA_model.svg", width: 100%),
    caption: [Блок-схема алгоритма фазово-градиентной автофокусировки],
  )<fig:PGA_model>

=== Map-drift
из вербы

== Фазовые множители <ref:phase_multi>
Данный подход основан на использовании навигационных данных, полученных от БИНС платформы. БИНС самолёта или БПЛА позволяет с помощью данных ГНСС или инерциальных измерений получить фактическое положение платформы в момент приёма отражённого сигнала. Таким образом, можно вычислить расстояние между фактическим и предполагаемым положением фазового центра антенны в момент приёма. Эта разница равносильна фазовой ошибке и дополнительной задержке сигнала, которая искажает отклик цели и должна быть исправлена. В данной работе коррекция траекторных искажений выполняется двумя методами (см. рисунок @fig:RDA_model): «базовым» и «приближённым» [E. Zaugg].

=== "Базовый" метод
  #figure(
    image("images/MOCO_geometry.svg", width: 70%),
    caption: [Изменение наклонной дальности при траекторных отклонениях],
  )<fig:MOCO_geometry>

  #figure(
    image("images/precise_corr.svg", width: 50%),
    caption: [Изменение циклограммы сигнала при траекторных отклонениях],
  )<fig:recv_signal_error>
  
В результате влияния траекторных нестабильностей изменяется дальность до цели (см. рисунок @fig:MOCO_geometry), тем самым изменяется фаза отклика цели и его момент регистрации (см. рисунок @fig:recv_signal_error), то есть отклику данной цели будет соответствовать иное положение на оси времени и, соответственно, дальности. В данном методе изменение фазы компенсируется умножением на согласованный фильтр, зависящим от времени по азимуту и от искажения траекторного сигнала на заданной дальности
$ H_("mc") (eta, Delta R_"ref") = exp(j dot 4 pi f_0 Delta R_("ref")(eta)), $<eq:precise_corr>
а смещение по времени компенсируется интерполяцией сигнала по "быстрому" времени. В результате, искажения для заданной цели будут полностью устранены, а цели на других дальностях останутся частично дефокусированными, но в меньшей степени, чем без компенсации.

=== "Приближённый" метод
В данном методе искажение наклонной дальности для каждой цели (т.е. ячейки по дальности в случае множества целей) представляется как сумма двух слагаемых:
$ Delta R(eta) = Delta R_("ref")(eta) +  Delta R_("diff")(eta), $ <eq:deltaR_decomp>
где $Delta R_("ref")(eta)$ --- искажение заданной наклонной дальности, а $Delta R_("diff")(eta)$ --- искажение наклонной дальности до каждой ячейки по дальности за вычетом предыдущего слагаемого, т.е. относительно заданной дальности.
Зависимость от времени по азимуту выражается в зависимости величины искажения от такового, а непосредственно сами дальности вычисляются до соответствующей прямой, параллельной оси азимута, т.е. они не зависят (константы) от азимута. Так как заданная наклонная дальность определена заранее и постоянна, первое слагаемое не зависит от произвольной дальности (т.е. координаты по дальности), а второе слагаемое от этой координаты зависит, что будет использовано далее.
Первый тип слагаемых компенсируется перед операцией сжатия по дальности, второй – сразу после неё. Данный метод позволяет получить приемлемое разрешение при исключении дорогостоящей в вычислительном плане операции интерполяции.

Рассмотрим подробнее математические соответствующие преобразования. В исходном сигнале @eq:raw_signal фазовую часть (без учёта огибающих) можно представить в виде:
$ s_0(tau, eta) = &exp(-j dot 4pi f_0 (R(eta) + Delta R_("ref")(eta) +  Delta R_("diff")(eta))/c) dot \
dot &exp(j dot pi K_r (tau - 2 (R(eta) + Delta R_("ref")(eta) +  Delta R_("diff")(eta))/c)^2) $
Это выражение можно разбить на множители следующим образом:
$ s_0(tau, eta) = &exp(-j dot 4pi f_0 R(eta) slash c) dot exp(j dot pi K_r (tau - 2 R(eta) slash c)^2) dot \
dot &exp(j dot 4pi  K_r (Delta R_("ref")(eta) ^2) / (c^2)) dot exp(-j dot 4pi f_0 (Delta R_("ref")(eta)) / (c)) dot \
dot &exp(-j dot 4pi K_r tau Delta R_("ref")(eta) slash c) dot \
dot &exp(j dot 8pi K_r Delta R_("ref")(eta)(Delta R_("diff")(eta) + R(eta)) slash c^2) dot \
dot &exp(j dot 4pi  K_r (Delta R_("diff")(eta) ^2) / (с^2)) dot exp(j dot 8pi  K_r (R(eta) Delta R_("diff")(eta)) / (c^2)) dot \
dot &exp(-j dot 4pi f_0 (Delta R_("diff")(eta)) / (c)) dot exp(-j dot 4pi K_r tau (Delta R_("diff")(eta)) / (c)),
$
где первые два множителя --- неискажённый сигнал, следующие три --- независящие от координаты по оси дальности искажения, а последние пять --- зависящие от неё.

Первый шаг коррекции применяется к исходной голограмме и выражается умножением на согласованный фильтр
$ H_("mc1") = exp(-j dot 4pi Delta R_("ref")(eta) (-f_0 c - K_r tau c + K_r Delta R_("ref")(eta)) / (c^2)), $ <eq:approx_corr_mc1>
который устраняет независящие от координаты по дальности искажения.

После сжатия по дальности один отсчёт голограммы по дальности будет соответствовать одной ячейке по дальности, и для компенсации зависящих от координаты по дальности искажений используется согласованный фильтр
$ H_("mc2") = &exp(-j dot 8pi K_r Delta R_("ref")(eta)(Delta R_("diff")(eta) + R(eta)) slash c^2) dot \ 
dot &exp(-j dot 4pi  K_r (Delta R_("diff")(eta) ^2) / (с^2)) dot exp(-j dot 8pi  K_r (R(eta) Delta R_("diff")(eta)) / (c^2)) dot \
dot &exp(j dot 4pi f_0 (Delta R_("diff")(eta)) / (c)) dot exp(j dot 4pi K_r tau (Delta R_("diff")(eta)) / (c)) $ <eq:approx_corr_mc2>

= Реализация (Модель)
== Реализация модели для точечных сигналов
Для анализа и оценки рассматриваемых подходов к компенсации ТН используется модель РСА авиационного базирования, блок-схема которой представлена на рисунке @fig:model_scheme.

  #figure(
    image("images/Point_target_model.svg", width: 100%),
    caption: [Блок-схема модели],
  )<fig:model_scheme>

=== Инициализация модели
Входные параметры модели описаны в таблице @tab:model_params.

#figure(
  table(
    columns: (auto, auto),
    align: (right, left),
    table.header(
      [*Параметр*], [*Обозначение*], // поменять местами
    ),
    [Разрешение по азимуту], [$"res"_a$],
    [Разрешение по дальности], [$"res"_r$],
    [Высота полёта], [$h$],
    [Угол раствора ДН], [$alpha$],
    [Скорость движения платформы], [$v$],
    [Длительность импульса], [$t_r$],
    [Ширина полосы излучаемого ЛЧМ сигнала], [_bw_],
    [Частота повторения импульса], [_prf_],
    [Частота несущей], [$f_0$],
    [Начальная координата платформы по оси _Y_], [$y_0$],
    [Ближняя граница], [$R_"min"$],
    [Дальняя граница], [$R_"max"$],
    [Время пролёта], [$T$],
    [Амплитуда ТН по оси _X_], [_dis_x_ampl_],
    [Частота ТН по оси _X_], [_dis_x_freq_],
    [Координаты целей], [-],
  ),
  caption : [Входные параметры модели для точечных целей]
)<tab:model_params>

В модели предполагается (см. рисунок @fig:model_geometry), что платформа (в идеальном случае) движется в 3-х мерном декартовом пространстве вдоль оси _X_ (т.е. по прямой $x = 0$) начиная с координаты $y_0$ в течение времени $T$ с постоянной скоростью $v$ на постоянной высоте $h$ по оси _Z_. Точечные цели расположены на высоте $h = 0$ в указанных координатах $(x, y)$. Диаграмма направленности имеет вид функции $sinc("scale" dot x)$ такой, что координаты $x = plus.minus a l p h a$ соответствуют уменьшению функции на 3 дБ относительно максимума, а максимум функции соответствует минимальной дальности подлёта к цели. Визуализация параметров зондирующего импульса представлена на рисунке @fig:recv_signal.

  #figure(
    image("images/Model_geometry.svg", width: 70%),
    caption: [Геометрия движения носителя РСА в модели],
  )<fig:model_geometry>

=== Генерация массива траекторных отклонений
В данной модели траекторные искажения представляются в виде гармонической функции с амплитудой _dis_x_ampl_ и частотой _dis_x_freq_, которая прибавляется к соответствующим координатам траектории платформы (в данном случае к оси _X_).

=== Генерация голограммы
Для каждой точечной цели с учётом ближней и дальней границы, а также ширины ДН и параметров сигнала вычисляется отклик для каждого положения платформы в момент излучения-приёма (т.е. для каждого отсчёта по азимуту). При вычислении фазы и времени регистрации полученного сигнала используется дальность до цели, вычисленная с учётом искажения траектории движения платформы. Полученные отклики взвешиваются на ДН антенны и объединяются в двумерный массив --- полученную голограмму. Размер массива по дальности определяется ближней, дальней границами и частотой дискретизации _f_s_, которая принимается равной $1,3 dot b w$.

=== Синтез РЛИ алгоритмом ДДА
Полученная голограмма затем обрабатывается дальностно-доплеровским алгоритмом (см главу @ref:RDA) с применением различных модификаций для компенсации ТН. Данные модификации применяются в зависимости от метода компенсации ТН, который требуется проанализировать. На каждом шаге работы ДДА производится контроль полученного РЛИ.

=== Анализ полученного изображения и контроль качества
На данном этапе производится интерполяция изображения каждой точечной цели, которое затем используется для оценки полученного разрешения и иных параметров.

== Анализ функции отклика точечной цели на РЛИ
//выделить портрет n x n
//Интерполяция в частотной области с помощью добавления нулей
//Нахождение макс, выделение профиля
//Измерение одномерных характеристик
//res_r, res_a, PSLR, ISLR
//Пример
Оценка качества полученных изображений производится по следующим параметрам: разрешение по азимуту и дальности, относительный и интегральный уровень мощности боковых лепестков. Алгоритм анализа отклика цели представлен на рисунке @fig:image_analysis_model.

  #figure(
    image("images/Target_analysis_model.svg", width: 40%),
    caption: [Алгоритм анализа отклика цели],
  )<fig:image_analysis_model>

   Для анализа данных параметров на РЛИ выделяется портрет выбранного отклика, представляющий из себя квадрат со стороной в некоторое количество отсчётов по каждой из осей изображения. Данный портрет затем интерполируется путём добавления нулей в частотной области (проиллюстрировано на рисунке @fig:image_interpolation): после двумерного БПФ портрета отсчёты на краях полученного двумерного массива соответствуют нулевой частоте, а в центре --- максимальной частоте по каждой из осей с соответствующим знаком; следовательно, для увеличения диапазона частот (и, соответственно, частоты дискретизации) в центр массива добавляются нули, а в результате четыре квадранта исходного массива окажутся в углах нового. От полученного массива затем берётся обратное двумерное БПФ, полученный массив изображения сохранит характеристики исходного изображения, но с увеличенной частотой отсчётов.

   #figure(
    table(
    columns: (auto, auto),
    stroke: none,
    align: (center, center),
    [#image("images/crop.svg", width: 100%)],
    [#image("images/crop_fft.svg", width: 100%)],
    [а)], [б)],
    [#image("images/crop_fft_interp.svg", width: 100%)],
    [#image("images/target.svg", width: 100%)],
    [в)], [г)],
  ),
    kind: image,
    caption: [Интерполяция изображения нулями в частотной области: портрет отклика одной из целей (в данном случае цель #2) (а), её двумерный спектр (б); её двумерный спектр после добавления нулей (в); портрет отклика цели после обратного БПФ (г). ],
  )<fig:image_interpolation>
   
   На полученном изображении определяется положение максимума и производится сечение профиля через найденный максимум по осям азимута и дальности. Полученное сечение позволяет оценить выбранные параметры: разрешение определяется по ширине главного лепестка на высоте -3 дБ, уровни боковых лепестков определяются соответствующими операциями над всем сечением. Вывод о результатах компенсации траекторный нестабильностей двумя методами и о пределах их применимости делается по итогам анализа параметров функций отклика всех точечных целей, заданных на сцене. Пример последовательности работы с РЛИ для определения данных параметров изображена на рисунке @fig:image_analysis.

  #figure(
    table(
    columns: (auto, auto),
    stroke: none,
    align: (center, center),
    [#image("images/scene.svg", width: 100%)],
    [#image("images/target.svg", width: 100%)],
    [а)], [б)],
    [#image("images/slice_a.svg", width: 100%)],
    [#image("images/slice_r.svg", width: 100%)],
    [в)], [г)],
  ),
    kind: image,
    caption: [Последовательность анализа параметров РЛИ: полученное изображение заданной сцены с выделенными откликами целей (а); увеличенное и интерполированное изображение одной из целей(в данном случае цель #2) (б), её сечение по азимуту (в) и дальности (г).],
  )<fig:image_analysis>
  
= Результаты моделирования
Для моделирование работы алгоритмов компенсации симуляции производится в следующем порядке:
+ Проверка реализации ДДА --- при отсутствии ТН
+ Демонстрация влияния искажений --- добавлены ТН, но без компенсации
+ Исследование алгоритмов компенсации --- при различных параметрах ТН

На каждом этапе проводится анализ промежуточных и итоговых результатов работы модели для оценки соответствующих параметров.

При исследовании алгоритмов компенсации определяется изменение измеренного разрешения по азимуту (как основной параметр функции отклика) при увеличении амплитуды траекторных отклонений. Данная зависимость исследуется при изменении других параметров ТН, таких как период или вид функции отклонения. На основании данных измерений делается вывод о допустимой величине ТН для каждого алгоритма и пределах применимости данных алгоритмов.

#let threshold_res = 1.3
#let threshold_slr = 0.5

Значения параметров модели, использованные при симуляциях, приведены в таблице @tab:sim_params. 
#figure(
  table(
    columns: (auto, auto),
    align: (right, left),
    table.header(
      [*Параметр*], [*Значение*],
    ),
    [$"res"_a$], [0,3 м],
    [$"res"_r$], [0,22 м],
    [$h$], [800 м],
    [$alpha$], [10#sym.degree],
    [$v$], [50 м/с],
    [$t_r$], [5 мкс],
    [_bw_], [600 МГц],
    [_prf_], [720 Гц],
    [$f_0$], [9,275 ГГц],
    [$y_0$], [-86 м],
    [$R_"min"$], [2000 м],
    [$R_"max"$], [3800 м],
    [$T$], [3,5 с],
    [_dis_x_ampl_], [варьируемый],
    [_dis_x_freq_], [варьируемый]
  ),
  caption : [Параметры симуляций]
)<tab:sim_params>
Координата $y_0$ выбрана для простоты таким образом, чтобы цели на оси $x = 0$ были на середине изображения. Координаты целей приведены в таблице @tab:target_coords. 
#figure(
  table(
    columns: (auto, auto),
    align: (right, left),
    table.header(
      [*Номер цели*], [*Координаты*],
    ),
    [1], [(2100, 0)],
    [2], [(2800, 0)],
    [3], [(3500, 0)],
    [4], [(2100, 50)],
    [5], [(2800, 50)],
    [6], [(3500, 50)],
    [7], [(2100, -50)],
    [8], [(2800, -50)],
    [9], [(3500, -50)],
  ),
  caption : [Координаты целей для симуляций]
)<tab:target_coords>
Амплитуда ТН _dis_x_ampl_ изменяется от 0 до 0,5 м с шагом 0,1 м. Значения частоты функции ТН _dis_x_freq_ взяты так, чтобы на длине пути укладывались соответственно 1, 2 и 3 её периода. Диапазоны значений выбраны так, чтобы наглядно пронаблюдать изменение изображения от сфокусированного до его разрушения. Исходя из описания алгоритмов компенсации и общих принципов ЦОС, предполагается, что при увеличении амплитуды ТН измеренное разрешение по азимуту будет экспоненциально ухудшаться. А при увеличении частоты ТН оно будет несущественно улучшаться, так как при увеличении частоты функция ТН будет лишь ухудшать соотношение сигнал-шум и тем самым увеличивать уровни боковых лепестков, не влияя на разрешение.

== Проверка реализации ДДА <ref:no_dis>
Для проверки корректности работы реализации алгоритма сначала проводится симуляция без добавления ТН. Значения параметров симуляции приведены в таблице @tab:rda_model_params. Координаты целей приведены в таблице @tab:target_coords.

#figure(
  table(
    columns: (auto, auto),
    align: (right, left),
    table.header(
      [*Параметр*], [*Значение*],
    ),
    [$"res"_a$], [0,3 м],
    [$"res"_r$], [0,22 м],
    [$h$], [800 м],
    [$alpha$], [10#sym.degree],
    [$v$], [50 м/с],
    [$t_r$], [5 мкс],
    [_bw_], [600 МГц],
    [_prf_], [720 Гц],
    [$f_0$], [9,275 ГГц],
    [$y_0$], [-86 м],
    [$R_"min"$], [2000 м],
    [$R_"max"$], [3800 м],
    [$T$], [3,5 с],
    [*_dis_x_ampl_*], [*0 м*],
    [_dis_x_freq_], [$2 slash T$ Гц]
  ),
  caption : [Параметры симуляции]
)<tab:rda_model_params>

Рассмотрим промежуточные шаги обработки голограммы на примере цели 2. Фрагменты голограммы с выбранной целью после последовательного выполнения операций алгоритма представлены на рисунках @fig:no_dis_fragments. На всех изображениях, где представлена голограмма, изображена её амплитуда, если не сказано иного. Красной линией показан закон изменения дальности до цели в соответствующих координатах (выведен в гл. @ref:RDA). Как видно из изображений, данный закон совпадает с откликом цели. На срезе полученного изображения цели видно, что его разрешения по азимуту и дальности, а также координаты  соответствуют заданным. Аналогичный результат получается для остальных целей. Таким образом, ДДА реализован корректно.

 #figure(
    table(
    columns: (auto, auto),
    stroke: none,
    align: (center, center),
    [#image("images/no_dis/pulse_compr.svg", width: 100%)],
    [#image("images/no_dis/azimuth_fft.svg", width: 100%)],
    [а)], [б)],
    [#image("images/no_dis/rcmc.svg", width: 100%)],
    [#image("images/no_dis/target.svg", width: 100%)],
    [в)], [г)],
    [#image("images/no_dis/az_slice.svg", width: 120%)],
    [#image("images/no_dis/ra_slice.svg", width: 120%)],
    [д)], [е)],
  ),
    caption: [Фрагменты голограммы после выполнения операций: сжатия по дальности (а), БПФ по азимуту (б), коррекции миграции дальности (в); Полученное изображение цели (г), его сечения по азимуту (д) и дальности (е); Красной линией изображён закон изменения дальности до цели в соответствующих координатах.],
    kind: image,
  )<fig:no_dis_fragments>

Также на рисунках @fig:no_dis_scene -- @fig:no_dis_targets представлено изображение сцены и РЛИ всех целей.

 #figure(
    image("images/no_dis/scene.svg", width: 80%),
    caption: [РЛИ моделируемой сцены],
 )<fig:no_dis_scene>

  #figure(
    image("images/no_dis/targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )<fig:no_dis_targets>

 В таблице @tab:no_dis_target_params представлены полученные значения параметров функций отклика целей: разрешение, относительный (PSLR) и интегральный (ISLR) уровень боковых лепестков по каждой из осей. Из таблицы следует, что параметры всех целей соотносятся с заданными значениями. Небольшой разброс значений разрешения связан с не вполне точной методикой измерения --- по ближайшим отсчётам, без проведения дополнительной интерполяции.

#let no_dis_res = csv("images/no_dis/results.csv")
  #figure(
   table(
     columns: (auto, ) + 6 * (1fr,),
     align: center,
     fill: (x, y) => if y <= 1 { blue.lighten(90%) },
     [], table.cell(colspan: 3, [*Азимут*]), table.cell(colspan: 3, [*Дальность*], ),
     [№], [*Разр., м*], [*PSLR, дБ*], [*ISLR, дБ*], [*Разр., м*], [*PSLR, дБ*], [*ISLR, дБ*],
     ..no_dis_res.flatten().map(float).map((x) => if calc.abs(x) < 1 { calc.round(x, digits: 2) } else { calc.round(x, digits: 1)}).map(str).map((s) => s.replace(".", ","))
   ),
   caption: [Параметры функций отклика полученных РЛИ целей]
 )<tab:no_dis_target_params>

== Влияние искажений на РЛИ <ref:no_corr>
Рассмотрим эффекты, возникающие на промежуточных этапах обработки голограммы и на конечном изображений вследствие наличия ТН. Значения параметров модели приведены в таблице @tab:no_corr_model_params. Координаты целей аналогичны предыдущему пункту @ref:no_dis (см. таблицу @tab:target_coords). Значение амплитуды искажения траектории выбрано из начала диапазона, чтобы продемонстрировать начало разрушения изображения с не слишком большими искажениями.

#figure(
  table(
    columns: (auto, auto),
    align: (right, left),
    table.header(
      [*Параметр*], [*Значение*],
    ),
    [$"res"_a$], [0,3 м],
    [$"res"_r$], [0,22 м],
    [$h$], [800 м],
    [$alpha$], [10#sym.degree],
    [$v$], [50 м/с],
    [$t_r$], [5 мкс],
    [_bw_], [600 МГц],
    [_prf_], [720 Гц],
    [$f_0$], [9,275 ГГц],
    [$y_0$], [-86 м],
    [$R_"min"$], [2000 м],
    [$R_"max"$], [3800 м],
    [$T$], [3,5 с],
    [*_dis_x_ampl_*], [0,2 м],
    [_dis_x_freq_], [$2 slash T$ Гц]
  ),
  caption : [Параметры симуляции]
)<tab:no_corr_model_params>

Сначала рассмотрим изменения на голограмме после применения операций ДДА на примере цели #2. Затем, для оценки влияния искажений детально рассмотрим голограмму после операции коррекции миграции дальности. Чтобы отобразить набег фазы, связанный с только искажением дальности, домножим строку голограммы на соответствующей дальности на $exp(-j dot 2 pi f_eta (- y_0/v))$. Приведённые в данном пункте изображения и графики будут затем использованы для оценки работы алгоритмов компенсации.

На рисунке @fig:no_corr_dR представлены искажения наклонных дальностей до целей, возникающих в результате траекторных отклонений. Аналогично п. @ref:no_dis на рисунке @fig:no_corr_fragments представлены фрагменты голограммы с выбранной целью после последовательного выполнения операций  алгоритма. Изображения демонстрируют, что цель по азимуту оказывается существенно размыта, а влияние искажений заметно на всех этапах формирования РЛИ.

 #figure(
    image("images/no_corr/dR.svg", width: 100%),
    caption: [Искажение наклонных дальностей до целей],
 )<fig:no_corr_dR>

 #figure(
        table(
    columns: (auto, auto),
    stroke: none,
    align: (center, center),
    [#image("images/no_corr/pulse_compr.svg", width: 100%)],
    [#image("images/no_corr/azimuth_fft.svg", width: 100%)],
    [а)], [б)],
    [#image("images/no_corr/rcmc.svg", width: 100%)],
    [#image("images/no_corr/target.svg", width: 100%)],
    [в)], [г)],
    [#image("images/no_corr/az_slice.svg", width: 120%)],
    [#image("images/no_corr/ra_slice.svg", width: 120%)],
    [д)], [е)],
  ),
    caption: [Фрагменты голограммы после выполнения операций: сжатия по дальности (а), БПФ по азимуту (б), коррекции миграции дальности (в); Полученное изображение цели (г), его сечения по азимуту (д) и дальности (е); Красной линией изображён закон изменения дальности до цели в соответствующих координатах.],
    kind: image,
  )<fig:no_corr_fragments>

Рассмотрим подробнее голограмму после коррекции миграции дальности. На рисунке @fig:no_corr_phase_rcmc, а) можно заметить, что набег фазы соответствует искажению траектории, показанном на рисунке @fig:no_corr_dR. К изображению @fig:no_corr_phase_rcmc, б) применён полосовой фильтр в диапазоне реальных доплеровских частот для центра изображения (элементы массива голограммы по азимуту соответствуют полосе частот _[-prf, +prf]_). Данное действие является частью алгоритма синтеза и используется для улучшения характеристик получаемых РЛИ. Также стоит отметить, что операция коррекция миграции дальности позволяет исправить искривления отклика цели вдоль оси азимута (в сравнении с искажениями на рисунке @fig:no_corr_dR), но не набег фазы, который и вносит основной вклад в размытия РЛИ. Данный набег и предстоит убрать для исправления размытия РЛИ, т.е. должен остаться только линейный набег фазы. Далее в работе вид графика фазы на данном шаге будет использоваться для оценки качества работы процедур компенсации.

 #figure(
    table(
    columns: (auto, auto),
    stroke: none,
    align: (center, center),
    [#image("images/no_corr/phase_rcmc.svg", width: 100%)],
    [#image("images/no_corr/target_rcmc.svg", width: 100%)],
    [а)], [б)],
  ),
    caption: [Набег фазы для выбранной цели, связанный с искажениями траектории (а); Искажение отклика выбранной цели на голограмме (б)],
    kind: image,
 )<fig:no_corr_phase_rcmc>

Приведём также полученные изображения всех целей (см. рисунок @fig:no_corr_all_targets). Отчётливо видно, что даже искажение менее величины разрешения по дальности уже приводит к существенной расфокусировки РЛИ. Определение параметров функций отклика в данном случае не имеет смысла. 

 #figure(
    image("images/no_corr/targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )<fig:no_corr_all_targets>

== Исследование алгоритмов компенсации <ref:corr_test>
Значения параметров модели, координат целей и амплитуд искажений аналогичны предыдущем пунктам и описаны выше. Теперь добавим процедуры компенсации ТН к модели и проведём аналогичные симуляции, чтобы сделать вывод о результатах работы алгоритмов.

=== "Базовый" метод <ref:prec_corr>
Рассмотрим детально процедуру компенсации для одной симуляции при _dis_x_ampl_ $ = 0,1$ м и _dis_x_freq_ $ = 2 slash T$ Гц (1 период). В соответствии с описанной ранне процедурой построим графики набега фазы в отклике цели, вызванного траекторными отклонениями (см. рисунок @fig:prec_corr_phase_rcmc). В соответствии с процедурой алгоритма, описанной в гл. @ref:phase_multi, набег для центральной цели был скомпенсирован полностью, на графике набега фазы виден постоянный набег, и на полученном РЛИ (см. рисунок @fig:prec_corr_all_targets) изображение данной цели полностью сфокусировано, о чём также говорят параметры в таблице @tab:prec_corr_target_params. Для остальных целей вид набега фазы включает остаточные искажения. Присутствующий шум на графиках может быть связан с некоторой неточностью определения сечения на голограмме. 

#figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/prec_sim/phase_rcmc3.svg", width: 100%)],
    [#image("images/prec_sim/phase_rcmc1.svg", width: 100%)],
    [#image("images/prec_sim/phase_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Набег фазы для целей, связанный с искажениями траектории],
 )<fig:prec_corr_phase_rcmc>

 Рассмотрим теперь вид отклика на голограмме (см. рисунок @fig:prec_corr_target_rcmc). Отклики верхних и нижних целей выглядят обрезанными из-за применённого фильтра, о чём сказано в предыдущем пункте. На всех фрагментах отклик цели представляет прямую линию, т.е. эффект от искажения, связанный с ошибкой времени регистрации прихода импульса и, соответственно, дальности также был скомпенсирован. 

  #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/prec_sim/target_rcmc3.svg", width: 100%)],
    [#image("images/prec_sim/target_rcmc1.svg", width: 100%)],
    [#image("images/prec_sim/target_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Искажение отклика целей на голограмме],
 )<fig:prec_corr_target_rcmc>

Полученные РЛИ целей представлены на рисунке @fig:prec_corr_all_targets. В данной симуляции для использованной величины траекторных отклонений видимые искажения на РЛИ отсутствуют, все цели сфокусированы.

  #figure(
    image("images/prec_sim/targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )<fig:prec_corr_all_targets>

 Параметры функций отклика приведены в таблице @tab:prec_corr_target_params. Для данной симуляции полученные параметры несущественно отличаются от идеального случая, из чего можно сделать вывод о том, что ТН в целом были исправлены. Тем не менее, параметры целей получаются хуже в силу того, что данный метод полностью исправляет искажения только для одной цели, и остальные цели остаются частично дефокусированными.
#let prec_corr_res = csv("images/prec_sim/sim2_T1/results.csv")
 #figure(
   table(
     columns: (auto, ) + 6 * (1fr,),
     align: center,
     fill: (x, y) => if y <= 1 { blue.lighten(90%) },
     [], table.cell(colspan: 3, [*Азимут*]), table.cell(colspan: 3, [*Дальность*], ),
     [№], [*Разр., м*], [*PSLR, дБ*], [*ISLR, дБ*], [*Разр., м*], [*PSLR, дБ*], [*ISLR, дБ*],
     ..prec_corr_res.flatten().map(float).map((x) => if calc.abs(x) < 1 { calc.round(x, digits: 2) } else { calc.round(x, digits: 1)}).map(str).map((s) => s.replace(".", ","))
   ),
   caption: [Параметры функций отклика полученных РЛИ целей]
 )<tab:prec_corr_target_params>

Теперь проведём симуляции во для всех значений параметров ТН и построим соответствующие зависимости измеренных параметров функций отклика целей от амплитуды и частоты ТН, которые изображены на рисунках @fig:prec_corr_res_graph, @fig:prec_corr_pslr_graph, @fig:prec_corr_islr_graph. Каждая точка на графике отображает усреднённое по всем целям разрешение. Как и было предсказано, на графики видно экспоненциальное ухудшение разрешения при увеличении амплитуды ТН.

#let num_t = 3
#let dis_ampl = read("images/prec_sim/T1_sim_params.txt").split("\n").at(0).split().map(float)
#let num_res = dis_ampl.len()
#let dis_freq = (1, 2, 3).map(it => it * read("images/prec_sim/T1_sim_params.txt").split("\n").at(4).split().map(float).at(0))

#figure(
  canvas({
    import draw: *

    plot.plot(
      legend: "inner-north-west",
      x-label: "амплитуда ТН, м",
      y-label: "разрешение по азимуту, м",
      y-min: 0.3,
      y-max: 0.8,
      x-grid: true,
      y-grid: true,
      //axis-style: "scientific",
      x-format: it => str(it).replace(".", ","),
      y-format: it => str(it).replace(".", ","),
      size: (12, 8),
      {
        for i in range(num_t){
          plot.add(
          dis_ampl.zip(read("images/prec_sim/T" + str(i + 1) + "_sim_params.txt").split("\n").at(1).split().map(float)),
          mark: "*",
          label: "Периодов ТН: " + str(i + 1),
          line: "spline",
          )
        }
        plot.add(
          dis_ampl.zip(num_res * (0.3 * threshold_res,)),
          style: (stroke: (paint: red, dash: "densely-dashed")),
          )
      }
    )
  }),

  supplement: "Рисунок",
  kind: image,
  caption: [График зависимости измеренного разрешения по азимуту от амплитуды и частоты ТН; Горизонтальной линией обозначено критическое значение разрешения, после которого изображение считается существенно размытым],
)<fig:prec_corr_res_graph>

#figure(
  canvas({
    import draw: *

    plot.plot(
      legend: "inner-north-west",
      x-label: "амплитуда ТН, м",
      y-label: "PSLR, дБ",
      y-min: -14,
      y-max: 0,
      x-grid: true,
      y-grid: true,
      //axis-style: "scientific",
      x-format: it => str(it).replace(".", ","),
      y-format: it => str(it).replace(".", ","),
      size: (12, 8),
      {
        for i in range(num_t){
          plot.add(
          dis_ampl.zip(read("images/prec_sim/T" + str(i + 1) + "_sim_params.txt").split("\n").at(2).split().map(float)),
          mark: "*",
          label: "Периодов ТН: " + str(i + 1),
          line: "spline",
          )
        }
        plot.add(
          dis_ampl.zip(num_res * (-13 * threshold_slr,)),
          style: (stroke: (paint: red, dash: "densely-dashed")),
          )
      }
    )
  }),

  supplement: "Рисунок",
  kind: image,
  caption: [График зависимости измеренного относительного уровня боковых лепестков от амплитуды и частоты ТН; Горизонтальной линией обозначено критическое значение, после которого изображение считается существенно размытым],
)<fig:prec_corr_pslr_graph>

#figure(
  canvas({
    import draw: *

    plot.plot(
      legend: "inner-north-west",
      x-label: "амплитуда ТН, м",
      y-label: "ISLR, дБ",
      y-min: -11,
      y-max: 8,
      x-grid: true,
      y-grid: true,
      //axis-style: "scientific",
      x-format: it => str(it).replace(".", ","),
      y-format: it => str(it).replace(".", ","),
      size: (12, 8),
      {
        for i in range(num_t){
          plot.add(
          dis_ampl.zip(read("images/prec_sim/T" + str(i + 1) + "_sim_params.txt").split("\n").at(3).split().map(float)),
          mark: "*",
          label: "Периодов ТН: " + str(i + 1),
          line: "spline",
          )
        }
        plot.add(
          dis_ampl.zip(num_res * (-10 * threshold_slr,)),
          style: (stroke: (paint: red, dash: "densely-dashed")),
          )
      }
    )
  }),

  supplement: "Рисунок",
  kind: image,
  caption: [График зависимости измеренного интегрального уровня боковых лепестков по азимуту от амплитуды и частоты ТН; Горизонтальной линией обозначено критическое значение, после которого изображение считается существенно размытым],
)<fig:prec_corr_islr_graph>

=== "Приближённый" метод <ref:approx_corr>
Для "приближённого" метода компенсации траекторных отклонений проведём аналогичные исследования. Как было сказано в гл. @ref:phase_multi, в данном методе для исправления ТН используются только фазовые множители, применение которых нацелено на коррекцию искажений в равной степени для всех целей в зависимости от их наклонной дальности. Ввиду этого остаточный набег фазы имеется у всех целей, как показано на рисунке @fig:approx_corr_phase_rcmc. 

 #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/approx_sim/phase_rcmc3.svg", width: 100%)],
    [#image("images/approx_sim/phase_rcmc1.svg", width: 100%)],
    [#image("images/approx_sim/phase_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Набег фазы для целей, связанный с искажениями траектории],
 )<fig:approx_corr_phase_rcmc>

 Отклики целей на соответствующих фрагментах голограммы для данной величины амплитуды отклонений (см. рисунок @fig:approx_corr_target_rcmc) не обнаруживают их влияния. Однако, ввиду того, что данный метод не компенсирует ошибку времени регистрации отражённого сигнала цели, в дальнейшем при увеличении амплитуды искажений их влияние будет проявляться более отчётливо.

  #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/approx_sim/target_rcmc3.svg", width: 100%)],
    [#image("images/approx_sim/target_rcmc1.svg", width: 100%)],
    [#image("images/approx_sim/target_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Искажение отклика целей на голограмме],
 )<fig:approx_corr_target_rcmc>

На полученных РЛИ целей существенные искажения отсутствуют, в данной симуляции все цели сфокусированы.

  #figure(
    image("images/approx_sim/targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )<fig:approx_corr_all_targets>

 В таблице @tab:approx_corr_target_params приведены параметры функций отклика целей. Для данной симуляции, как и в случае "базового" метода, полученные параметры несущественно отличаются от идеального случая, т.е. ТН в целом были исправлены. Тем не менее, параметры целей получаются хуже в силу того, что данный метод не исправляет фазовые искажения полностью, а ошибка времени регистрации в процедуре компенсации не исправляется вовсе, однако в данном случае для её исправления хватает операции коррекции миграции дальности ДДА. В дальнейшем это также будет вносить вклад в ухудшения изображения.
#let approx_corr_res = csv("images/approx_sim/sim2_T1/results.csv")
 #figure(
   table(
     columns: (auto, ) + 6 * (1fr,),
     align: center,
     fill: (x, y) => if y <= 1 { blue.lighten(90%) },
     [], table.cell(colspan: 3, [*Азимут*]), table.cell(colspan: 3, [*Дальность*], ),
     [№], [*Разр., м*], [*PSLR, дБ*], [*ISLR, дБ*], [*Разр., м*], [*PSLR, дБ*], [*ISLR, дБ*],
     ..approx_corr_res.flatten().map(float).map((x) => if calc.abs(x) < 1 { calc.round(x, digits: 2) } else { calc.round(x, digits: 1)}).map(str).map((s) => s.replace(".", ","))
   ),
   caption: [Параметры функций отклика полученных РЛИ целей]
 )<tab:approx_corr_target_params>

 Теперь проведём симуляции во для всех значений параметров ТН и построим соответствующие зависимости измеренных параметров функций отклика целей от амплитуды и частоты ТН, которые изображены на рисунках @fig:approx_corr_res_graph, @fig:approx_corr_pslr_graph, @fig:approx_corr_islr_graph. Каждая точка на графике отображает усреднённое по всем целям разрешение. Как и было предсказано, на графики видно экспоненциальное ухудшение разрешения при увеличении амплитуды ТН.

#let num_t = 3
#let dis_ampl = read("images/approx_sim/T1_sim_params.txt").split("\n").at(0).split().map(float)
#let num_res = dis_ampl.len()
#let dis_freq = (1, 2, 3).map(it => it * read("images/approx_sim/T1_sim_params.txt").split("\n").at(4).split().map(float).at(0))

#figure(
  canvas({
    import draw: *

    plot.plot(
      legend: "inner-north-west",
      x-label: "амплитуда ТН, м",
      y-label: "разрешение по азимуту, м",
      y-min: 0.3,
      y-max: 0.8,
      x-grid: true,
      y-grid: true,
      //axis-style: "scientific",
      x-format: it => str(it).replace(".", ","),
      y-format: it => str(it).replace(".", ","),
      size: (12, 8),
      {
        for i in range(num_t){
          plot.add(
          dis_ampl.zip(read("images/approx_sim/T" + str(i + 1) + "_sim_params.txt").split("\n").at(1).split().map(float)),
          mark: "*",
          label: "Периодов ТН: " + str(i + 1),
          line: "spline",
          )
        }
        plot.add(
          dis_ampl.zip(num_res * (0.3 * threshold_res,)),
          style: (stroke: (paint: red, dash: "densely-dashed")),
          )
      }
    )
  }),

  supplement: "Рисунок",
  kind: image,
  caption: [График зависимости измеренного разрешения по азимуту от амплитуды и частоты ТН; Горизонтальной линией обозначено критическое значение разрешения, после которого изображение считается существенно размытым],
)<fig:approx_corr_res_graph>

#figure(
  canvas({
    import draw: *

    plot.plot(
      legend: "inner-north-west",
      x-label: "амплитуда ТН, м",
      y-label: "PSLR, дБ",
      y-min: -14,
      y-max: 0,
      x-grid: true,
      y-grid: true,
      //axis-style: "scientific",
      x-format: it => str(it).replace(".", ","),
      y-format: it => str(it).replace(".", ","),
      size: (12, 8),
      {
        for i in range(num_t){
          plot.add(
          dis_ampl.zip(read("images/approx_sim/T" + str(i + 1) + "_sim_params.txt").split("\n").at(2).split().map(float)),
          mark: "*",
          label: "Периодов ТН: " + str(i + 1),
          line: "spline",
          )
        }
        plot.add(
          dis_ampl.zip(num_res * (-13 * threshold_slr,)),
          style: (stroke: (paint: red, dash: "densely-dashed")),
          )
      }
    )
  }),

  supplement: "Рисунок",
  kind: image,
  caption: [График зависимости измеренного относительного уровня боковых лепестков от амплитуды и частоты ТН; Горизонтальной линией обозначено критическое значение, после которого изображение считается существенно размытым],
)<fig:approx_corr_pslr_graph>

#figure(
  canvas({
    import draw: *

    plot.plot(
      legend: "inner-north-west",
      x-label: "амплитуда ТН, м",
      y-label: "ISLR, дБ",
      y-min: -11,
      y-max: 8,
      x-grid: true,
      y-grid: true,
      //axis-style: "scientific",
      x-format: it => str(it).replace(".", ","),
      y-format: it => str(it).replace(".", ","),
      size: (12, 8),
      {
        for i in range(num_t){
          plot.add(
          dis_ampl.zip(read("images/approx_sim/T" + str(i + 1) + "_sim_params.txt").split("\n").at(3).split().map(float)),
          mark: "*",
          label: "Периодов ТН: " + str(i + 1),
          line: "spline",
          )
        }
        plot.add(
          dis_ampl.zip(num_res * (-10 * threshold_slr,)),
          style: (stroke: (paint: red, dash: "densely-dashed")),
          )
      }
    )
  }),

  supplement: "Рисунок",
  kind: image,
  caption: [График зависимости измеренного интегрального уровня боковых лепестков по азимуту от амплитуды и частоты ТН; Горизонтальной линией обозначено критическое значение, после которого изображение считается существенно размытым],
)<fig:approx_corr_islr_graph>

/*
== Компенсация искажений при больших ТН
Отдельно промоделируем работу алгоритмов компенсации при траекторных отклонениях на порядок больше размера ячейки РЛИ по дальности, т.е. *_dis_x_ampl = 4 м_*. Остальные параметры оставим без изменения. Сначала рассмотрим влияние искажений, затем их компенсацию обоими методами.

=== Симуляция без компенсации ТН
Аналогично предыдущим пунктам, рассмотрим соответствующие этапы синтеза РЛИ. На @fig:no_corr_dR_big приведены графики искажения наклонных дальностей, результат которых модно наблюдать на этапах синтеза из @fig:no_corr_fragments_big и полученных РЛИ целей  @fig:no_corr_all_targets_big в виде полного разрушения изображений. На фрагменте @fig:no_corr_phase_rcmc_big для цели #2 обратим внимание, что её отклик уже не близок к прямой линии, а оказывается существенно искривлён.

#figure(
    image("images/no_corr_big/no_corr_dR.svg", width: 100%),
    caption: [Искажение наклонных дальностей до целей],
 )<fig:no_corr_dR_big>

 #figure(
    table(
    columns: (auto, auto),
    stroke: none,
    align: (center, center),
    [#image("images/no_corr_big/no_corr_pulse_compr.svg", width: 100%)],
    [#image("images/no_corr_big/no_corr_azimuth_fft.svg", width: 100%)],
    [а)], [б)],
    [#image("images/no_corr_big/no_corr_rcmc.svg", width: 100%)],
    [#image("images/no_corr_big/no_corr_final.svg", width: 100%)],
    [в)], [г)],
    [#image("images/no_corr_big/no_corr_azimuth_slice.svg", width: 120%)],
    [#image("images/no_corr_big/no_corr_range_slice.svg", width: 120%)],
    [д)], [е)],
  ),
    caption: [Фрагменты голограммы после выполнения операций: сжатия по дальности (а), БПФ по азимуту (б), коррекции миграции дальности (в); Полученное изображение цели (г), его сечения по азимуту (д) и дальности (е).],
    kind: image,
  )<fig:no_corr_fragments_big>

 #figure(
    table(
    columns: (auto, auto),
    stroke: none,
    align: (center, center),
    [#image("images/no_corr_big/no_corr_phase_rcmc.svg", width: 100%)],
    [#image("images/no_corr_big/no_corr_target_rcmc.svg", width: 100%)],
    [а)], [б)],
  ),
    kind: image,
    caption: [Набег фазы для выбранной цели, связанный с искажениями траектории (а); Искажение отклика выбранной цели на голограмме (б)],
 )<fig:no_corr_phase_rcmc_big>

 #figure(
    image("images/no_corr_big/no_corr_all_targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )<fig:no_corr_all_targets_big>

=== Компенсация "точным" методом
Применим "точный" метод для компенсации искажений. В соответствии с процедурой алгоритма, центральная цель полностью избавлена от искажений (@fig:PrCorr_phase_rcmc_big). Цели на аналогичной ей дальности частично дефокусированы. Остаточное искажение для остальных целей оказывается настолько велико, что их изображения разрушены (@fig:PrCorr_all_targets_big). Отметим также, что благодаря компенсации ошибки времени регистрации отклика цели, амплитуда откликов (@fig:PrCorr_target_rcmc_big) практически полностью выпрямляется, что вносит вклад в компенсацию отклонений.

#figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/prec_corr_big/PrCorr_phase_rcmc3.svg", width: 100%)],
    [#image("images/prec_corr_big/PrCorr_phase_rcmc1.svg", width: 100%)],
    [#image("images/prec_corr_big/PrCorr_phase_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Набег фазы для целей, связанный с искажениями траектории],
 )<fig:PrCorr_phase_rcmc_big>

  #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/prec_corr_big/PrCorr_target_rcmc3.svg", width: 100%)],
    [#image("images/prec_corr_big/PrCorr_target_rcmc1.svg", width: 100%)],
    [#image("images/prec_corr_big/PrCorr_target_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Искажение отклика целей на голограмме],
 )<fig:PrCorr_target_rcmc_big>

  #figure(
    image("images/prec_corr_big/PrCorr_all_targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )<fig:PrCorr_all_targets_big>

 #figure(
   table(
     columns: (auto, ) + 6 * (1fr,),
     align: center,
     fill: (x, y) => if y <= 1 { blue.lighten(90%) },
     [], table.cell(colspan: 3, [*Азимут*]), table.cell(colspan: 3, [*Дальность*], ),
     [№], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*],
     ..csv("data/PrCorr_params_big.csv").flatten().map(float).map((x) => if calc.abs(x) < 1 { calc.round(x, digits: 2) } else { calc.round(x, digits: 1)}).map(str).map((s) => s.replace(".", ","))
   ),
   caption: [Параметры функций отклика полученных РЛИ целей]
 )<tab:PrCorr_target_params_big>

 === Компенсация "приближённым" методом
В отличие от предыдущего пункта, "приближённому" методу не удаётся справиться с ТН. Существенный статочный набег фазы (@fig:approx_corr_phase_rcmc_big) и искривление амплитуды отклика (@fig:ApCorr_target_rcmc_big), вызванное существенно большей ошибкой времени регистрации приводят к тому, что РЛИ всех целей оказываются разрушены, что показано на @fig:ApCorr_all_targets_big.

#figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/appr_corr_big/ApCorr_phase_rcmc3.svg", width: 100%)],
    [#image("images/appr_corr_big/ApCorr_phase_rcmc1.svg", width: 100%)],
    [#image("images/appr_corr_big/ApCorr_phase_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Набег фазы для целей, связанный с искажениями траектории],
 )<fig:ApCorr_phase_rcmc_big>

  #figure(
    table(
    columns: (auto,),
    stroke: none,
    align: (center,),
    [#image("images/appr_corr_big/ApCorr_target_rcmc3.svg", width: 100%)],
    [#image("images/appr_corr_big/ApCorr_target_rcmc1.svg", width: 100%)],
    [#image("images/appr_corr_big/ApCorr_target_rcmc2.svg", width: 100%)],
  ),
    kind: image,
    caption: [Искажение отклика целей на голограмме],
 )<fig:ApCorr_target_rcmc_big>

  #figure(
    image("images/appr_corr_big/ApCorr_all_targets.svg", width: 100%),
    caption: [РЛИ всех целей],
 )<fig:ApCorr_all_targets_big>

 #figure(
   table(
     columns: (auto, ) + 6 * (1fr,),
     align: center,
     fill: (x, y) => if y <= 1 { blue.lighten(90%) },
     [], table.cell(colspan: 3, [*Азимут*]), table.cell(colspan: 3, [*Дальность*], ),
     [№], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*], [*Разреш., м*], [*PSLR, дБ*], [*ISLR, дБ*],
     ..csv("data/ApCorr_params_big.csv").flatten().map(float).map((x) => if calc.abs(x) < 1 { calc.round(x, digits: 2) } else { calc.round(x, digits: 1)}).map(str).map((s) => s.replace(".", ","))
   ),
   caption: [Параметры функций отклика полученных РЛИ целей]
 )<tab:ApCorr_target_params_big>

== Вывод
 Здесь будет большой вывод обо всё происходящем.